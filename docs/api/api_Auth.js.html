<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: api/Auth.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: api/Auth.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Authentication &amp; Authorization System for LLM Runner Router
 * Supports JWT, API Keys, OAuth 2.0, and role-based access control
 */

import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';
import passport from 'passport';
import { Strategy as LocalStrategy } from 'passport-local';
import { Strategy as JwtStrategy, ExtractJwt } from 'passport-jwt';
import { Strategy as OAuth2Strategy } from 'passport-oauth2';
import { v4 as uuidv4 } from 'uuid';
import { EventEmitter } from 'events';

export class AuthenticationManager extends EventEmitter {
  constructor(options = {}) {
    super();
    this.options = {
      jwtSecret: options.jwtSecret || process.env.JWT_SECRET || 'your-secret-key',
      jwtExpiresIn: options.jwtExpiresIn || '24h',
      refreshTokenExpiresIn: options.refreshTokenExpiresIn || '7d',
      bcryptRounds: options.bcryptRounds || 12,
      apiKeyLength: options.apiKeyLength || 32,
      maxLoginAttempts: options.maxLoginAttempts || 5,
      lockoutDuration: options.lockoutDuration || 15 * 60 * 1000, // 15 minutes
      sessionSecret: options.sessionSecret || process.env.SESSION_SECRET || 'session-secret',
      oauth: {
        clientID: options.oauth?.clientID || process.env.OAUTH_CLIENT_ID,
        clientSecret: options.oauth?.clientSecret || process.env.OAUTH_CLIENT_SECRET,
        callbackURL: options.oauth?.callbackURL || '/auth/oauth2/callback',
        authorizationURL: options.oauth?.authorizationURL || 'https://example.com/oauth2/authorize',
        tokenURL: options.oauth?.tokenURL || 'https://example.com/oauth2/token',
        userProfileURL: options.oauth?.userProfileURL || 'https://example.com/api/user',
        scope: options.oauth?.scope || ['read', 'write']
      },
      ...options
    };

    // In-memory stores (replace with database in production)
    this.users = new Map();
    this.apiKeys = new Map();
    this.refreshTokens = new Map();
    this.blacklistedTokens = new Set();
    this.loginAttempts = new Map();
    this.sessions = new Map();

    // Role-based permissions
    this.roles = {
      admin: {
        permissions: ['*'],
        description: 'Full system access'
      },
      user: {
        permissions: ['model:read', 'inference:create', 'chat:create'],
        description: 'Standard user access'
      },
      readonly: {
        permissions: ['model:read', 'health:read', 'metrics:read'],
        description: 'Read-only access'
      },
      api: {
        permissions: ['inference:create', 'chat:create', 'model:read'],
        description: 'API access for automated systems'
      }
    };

    this.initialize();
  }

  /**
   * Initialize authentication system
   */
  initialize() {
    this.setupPassport();
    this.createDefaultUsers();
    this.emit('initialized');
  }

  /**
   * Setup Passport.js strategies
   */
  setupPassport() {
    // Local strategy for username/password
    passport.use(new LocalStrategy({
      usernameField: 'username',
      passwordField: 'password'
    }, async (username, password, done) => {
      try {
        const user = await this.authenticateUser(username, password);
        if (!user) {
          return done(null, false, { message: 'Invalid credentials' });
        }
        return done(null, user);
      } catch (error) {
        return done(error);
      }
    }));

    // JWT strategy for token-based auth
    passport.use(new JwtStrategy({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: this.options.jwtSecret,
      issuer: 'llm-router',
      audience: 'llm-router-api'
    }, async (payload, done) => {
      try {
        // Check if token is blacklisted
        if (this.blacklistedTokens.has(payload.jti)) {
          return done(null, false, { message: 'Token has been revoked' });
        }

        const user = this.users.get(payload.sub);
        if (!user) {
          return done(null, false, { message: 'User not found' });
        }

        return done(null, user);
      } catch (error) {
        return done(error);
      }
    }));

    // OAuth 2.0 strategy
    if (this.options.oauth.clientID &amp;&amp; this.options.oauth.clientSecret) {
      passport.use(new OAuth2Strategy({
        authorizationURL: this.options.oauth.authorizationURL,
        tokenURL: this.options.oauth.tokenURL,
        clientID: this.options.oauth.clientID,
        clientSecret: this.options.oauth.clientSecret,
        callbackURL: this.options.oauth.callbackURL
      }, async (accessToken, refreshToken, profile, done) => {
        try {
          // Find or create user based on OAuth profile
          let user = Array.from(this.users.values()).find(u => u.oauthId === profile.id);
          
          if (!user) {
            user = await this.createUser({
              username: profile.username || profile.email || `oauth_${profile.id}`,
              email: profile.email,
              name: profile.displayName || profile.name,
              role: 'user',
              oauthId: profile.id,
              oauthProvider: 'oauth2',
              verified: true
            });
          }

          return done(null, user);
        } catch (error) {
          return done(error);
        }
      }));
    }

    // Serialize/deserialize user for sessions
    passport.serializeUser((user, done) => {
      done(null, user.id);
    });

    passport.deserializeUser((id, done) => {
      const user = this.users.get(id);
      done(null, user);
    });
  }

  /**
   * Create default users for testing
   */
  async createDefaultUsers() {
    // Admin user
    await this.createUser({
      username: 'admin',
      password: 'admin123',
      email: 'admin@llm-router.com',
      name: 'Administrator',
      role: 'admin',
      verified: true
    });

    // Regular user
    await this.createUser({
      username: 'user',
      password: 'user123',
      email: 'user@llm-router.com',
      name: 'Regular User',
      role: 'user',
      verified: true
    });

    // API user
    await this.createUser({
      username: 'api',
      password: 'api123',
      email: 'api@llm-router.com',
      name: 'API User',
      role: 'api',
      verified: true
    });
  }

  /**
   * Create a new user
   */
  async createUser(userData) {
    try {
      const userId = uuidv4();
      const hashedPassword = userData.password ? await bcrypt.hash(userData.password, this.options.bcryptRounds) : null;

      const user = {
        id: userId,
        username: userData.username,
        password: hashedPassword,
        email: userData.email,
        name: userData.name,
        role: userData.role || 'user',
        permissions: this.roles[userData.role || 'user']?.permissions || [],
        verified: userData.verified || false,
        oauthId: userData.oauthId,
        oauthProvider: userData.oauthProvider,
        createdAt: new Date(),
        lastLogin: null,
        loginCount: 0,
        active: true,
        metadata: userData.metadata || {}
      };

      this.users.set(userId, user);
      this.emit('userCreated', user);
      
      return { ...user, password: undefined }; // Don't return password
    } catch (error) {
      this.emit('error', error);
      throw error;
    }
  }

  /**
   * Authenticate user with username/password
   */
  async authenticateUser(username, password) {
    try {
      // Check for rate limiting
      const attemptKey = `login:${username}`;
      const attempts = this.loginAttempts.get(attemptKey) || { count: 0, lockedUntil: null };

      if (attempts.lockedUntil &amp;&amp; attempts.lockedUntil > Date.now()) {
        throw new Error('Account temporarily locked due to too many failed attempts');
      }

      // Find user
      const user = Array.from(this.users.values()).find(u => u.username === username);
      if (!user || !user.active) {
        this.recordFailedAttempt(attemptKey);
        return null;
      }

      // Check password
      const isValid = await bcrypt.compare(password, user.password);
      if (!isValid) {
        this.recordFailedAttempt(attemptKey);
        return null;
      }

      // Clear failed attempts on successful login
      this.loginAttempts.delete(attemptKey);

      // Update user login info
      user.lastLogin = new Date();
      user.loginCount++;

      this.emit('userAuthenticated', user);
      return { ...user, password: undefined };
    } catch (error) {
      this.emit('error', error);
      throw error;
    }
  }

  /**
   * Record failed login attempt
   */
  recordFailedAttempt(attemptKey) {
    const attempts = this.loginAttempts.get(attemptKey) || { count: 0, lockedUntil: null };
    attempts.count++;

    if (attempts.count >= this.options.maxLoginAttempts) {
      attempts.lockedUntil = Date.now() + this.options.lockoutDuration;
      this.emit('accountLocked', { attemptKey, lockedUntil: attempts.lockedUntil });
    }

    this.loginAttempts.set(attemptKey, attempts);
  }

  /**
   * Generate JWT token
   */
  generateTokens(user) {
    const tokenId = uuidv4();
    const now = Math.floor(Date.now() / 1000);

    // Access token
    const accessToken = jwt.sign({
      sub: user.id,
      username: user.username,
      role: user.role,
      permissions: user.permissions,
      jti: tokenId,
      iat: now,
      iss: 'llm-router',
      aud: 'llm-router-api'
    }, this.options.jwtSecret, {
      expiresIn: this.options.jwtExpiresIn
    });

    // Refresh token
    const refreshTokenId = uuidv4();
    const refreshToken = jwt.sign({
      sub: user.id,
      jti: refreshTokenId,
      type: 'refresh',
      iat: now,
      iss: 'llm-router',
      aud: 'llm-router-api'
    }, this.options.jwtSecret, {
      expiresIn: this.options.refreshTokenExpiresIn
    });

    // Store refresh token
    this.refreshTokens.set(refreshTokenId, {
      userId: user.id,
      token: refreshToken,
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
    });

    this.emit('tokensGenerated', { userId: user.id, tokenId, refreshTokenId });

    return {
      accessToken,
      refreshToken,
      tokenType: 'Bearer',
      expiresIn: this.options.jwtExpiresIn,
      tokenId,
      refreshTokenId
    };
  }

  /**
   * Refresh access token
   */
  async refreshAccessToken(refreshToken) {
    try {
      const decoded = jwt.verify(refreshToken, this.options.jwtSecret);
      
      if (decoded.type !== 'refresh') {
        throw new Error('Invalid refresh token');
      }

      const storedToken = this.refreshTokens.get(decoded.jti);
      if (!storedToken || storedToken.token !== refreshToken) {
        throw new Error('Refresh token not found or invalid');
      }

      if (storedToken.expiresAt &lt; new Date()) {
        this.refreshTokens.delete(decoded.jti);
        throw new Error('Refresh token expired');
      }

      const user = this.users.get(decoded.sub);
      if (!user || !user.active) {
        throw new Error('User not found or inactive');
      }

      // Generate new tokens
      const tokens = this.generateTokens(user);
      
      // Remove old refresh token
      this.refreshTokens.delete(decoded.jti);

      this.emit('tokenRefreshed', { userId: user.id, oldTokenId: decoded.jti });
      
      return tokens;
    } catch (error) {
      this.emit('error', error);
      throw error;
    }
  }

  /**
   * Revoke token (blacklist)
   */
  revokeToken(token) {
    try {
      const decoded = jwt.decode(token);
      if (decoded &amp;&amp; decoded.jti) {
        this.blacklistedTokens.add(decoded.jti);
        this.emit('tokenRevoked', { tokenId: decoded.jti, userId: decoded.sub });
      }
    } catch (error) {
      this.emit('error', error);
    }
  }

  /**
   * Generate API key
   */
  async generateApiKey(userId, name, permissions = [], expiresAt = null) {
    try {
      const user = this.users.get(userId);
      if (!user) {
        throw new Error('User not found');
      }

      const apiKeyId = uuidv4();
      const key = this.generateRandomKey(this.options.apiKeyLength);
      const hashedKey = await bcrypt.hash(key, this.options.bcryptRounds);

      const apiKey = {
        id: apiKeyId,
        userId: userId,
        name: name,
        key: hashedKey,
        permissions: permissions.length > 0 ? permissions : user.permissions,
        createdAt: new Date(),
        expiresAt: expiresAt,
        lastUsed: null,
        usageCount: 0,
        active: true
      };

      this.apiKeys.set(apiKeyId, apiKey);
      this.emit('apiKeyGenerated', { userId, apiKeyId, name });

      return {
        id: apiKeyId,
        key: `llmr_${key}`, // Prefix for identification
        name: name,
        permissions: apiKey.permissions,
        expiresAt: expiresAt
      };
    } catch (error) {
      this.emit('error', error);
      throw error;
    }
  }

  /**
   * Validate API key
   */
  async validateApiKey(key) {
    try {
      if (!key.startsWith('llmr_')) {
        return null;
      }

      const cleanKey = key.replace('llmr_', '');
      
      for (const [id, apiKey] of this.apiKeys) {
        if (!apiKey.active) continue;
        
        if (apiKey.expiresAt &amp;&amp; apiKey.expiresAt &lt; new Date()) {
          apiKey.active = false;
          continue;
        }

        const isValid = await bcrypt.compare(cleanKey, apiKey.key);
        if (isValid) {
          // Update usage stats
          apiKey.lastUsed = new Date();
          apiKey.usageCount++;

          const user = this.users.get(apiKey.userId);
          if (!user || !user.active) {
            return null;
          }

          this.emit('apiKeyUsed', { apiKeyId: id, userId: apiKey.userId });

          return {
            user: { ...user, password: undefined },
            apiKey: { ...apiKey, key: undefined },
            permissions: apiKey.permissions
          };
        }
      }

      return null;
    } catch (error) {
      this.emit('error', error);
      return null;
    }
  }

  /**
   * Revoke API key
   */
  revokeApiKey(apiKeyId) {
    const apiKey = this.apiKeys.get(apiKeyId);
    if (apiKey) {
      apiKey.active = false;
      this.emit('apiKeyRevoked', { apiKeyId, userId: apiKey.userId });
      return true;
    }
    return false;
  }

  /**
   * Check user permissions
   */
  hasPermission(user, permission) {
    if (!user || !user.permissions) {
      return false;
    }

    // Admin has all permissions
    if (user.permissions.includes('*')) {
      return true;
    }

    // Check exact permission
    if (user.permissions.includes(permission)) {
      return true;
    }

    // Check wildcard permissions
    const permissionParts = permission.split(':');
    for (let i = permissionParts.length; i > 0; i--) {
      const wildcardPermission = permissionParts.slice(0, i).join(':') + ':*';
      if (user.permissions.includes(wildcardPermission)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Generate random key
   */
  generateRandomKey(length) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i &lt; length; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }

  /**
   * Get user by ID
   */
  getUser(userId) {
    const user = this.users.get(userId);
    return user ? { ...user, password: undefined } : null;
  }

  /**
   * Update user
   */
  async updateUser(userId, updates) {
    const user = this.users.get(userId);
    if (!user) {
      throw new Error('User not found');
    }

    // Hash password if updating
    if (updates.password) {
      updates.password = await bcrypt.hash(updates.password, this.options.bcryptRounds);
    }

    // Update permissions if role changed
    if (updates.role &amp;&amp; this.roles[updates.role]) {
      updates.permissions = this.roles[updates.role].permissions;
    }

    Object.assign(user, updates);
    this.emit('userUpdated', { userId, updates });
    
    return { ...user, password: undefined };
  }

  /**
   * Delete user
   */
  deleteUser(userId) {
    const user = this.users.get(userId);
    if (!user) {
      return false;
    }

    // Revoke all API keys for this user
    for (const [keyId, apiKey] of this.apiKeys) {
      if (apiKey.userId === userId) {
        this.revokeApiKey(keyId);
      }
    }

    // Remove all refresh tokens for this user
    for (const [tokenId, refreshToken] of this.refreshTokens) {
      if (refreshToken.userId === userId) {
        this.refreshTokens.delete(tokenId);
      }
    }

    this.users.delete(userId);
    this.emit('userDeleted', { userId });
    
    return true;
  }

  /**
   * List users with pagination
   */
  listUsers(options = {}) {
    const { limit = 50, offset = 0, role, active } = options;
    
    let users = Array.from(this.users.values());
    
    // Apply filters
    if (role) {
      users = users.filter(u => u.role === role);
    }
    
    if (active !== undefined) {
      users = users.filter(u => u.active === active);
    }

    // Sort by creation date
    users.sort((a, b) => b.createdAt - a.createdAt);

    // Apply pagination
    const total = users.length;
    const paginatedUsers = users.slice(offset, offset + limit);

    return {
      users: paginatedUsers.map(u => ({ ...u, password: undefined })),
      total,
      limit,
      offset,
      hasMore: offset + limit &lt; total
    };
  }

  /**
   * List API keys for user
   */
  listApiKeys(userId) {
    const apiKeys = [];
    
    for (const [id, apiKey] of this.apiKeys) {
      if (apiKey.userId === userId) {
        apiKeys.push({
          ...apiKey,
          key: undefined // Don't return the actual key
        });
      }
    }

    return apiKeys.sort((a, b) => b.createdAt - a.createdAt);
  }

  /**
   * Get authentication statistics
   */
  getStats() {
    const now = new Date();
    const activeUsers = Array.from(this.users.values()).filter(u => u.active).length;
    const activeApiKeys = Array.from(this.apiKeys.values()).filter(k => k.active &amp;&amp; (!k.expiresAt || k.expiresAt > now)).length;
    const blacklistedTokensCount = this.blacklistedTokens.size;
    const refreshTokensCount = this.refreshTokens.size;

    return {
      totalUsers: this.users.size,
      activeUsers,
      totalApiKeys: this.apiKeys.size,
      activeApiKeys,
      blacklistedTokens: blacklistedTokensCount,
      activeRefreshTokens: refreshTokensCount,
      lockedAccounts: Array.from(this.loginAttempts.values()).filter(a => a.lockedUntil &amp;&amp; a.lockedUntil > Date.now()).length
    };
  }

  /**
   * Cleanup expired tokens and sessions
   */
  cleanup() {
    const now = new Date();
    
    // Remove expired refresh tokens
    for (const [tokenId, refreshToken] of this.refreshTokens) {
      if (refreshToken.expiresAt &lt; now) {
        this.refreshTokens.delete(tokenId);
      }
    }

    // Remove expired API keys
    for (const [keyId, apiKey] of this.apiKeys) {
      if (apiKey.expiresAt &amp;&amp; apiKey.expiresAt &lt; now) {
        apiKey.active = false;
      }
    }

    // Remove old blacklisted tokens (older than 24 hours)
    const cutoff = Date.now() - (24 * 60 * 60 * 1000);
    for (const tokenId of this.blacklistedTokens) {
      try {
        const decoded = jwt.decode(tokenId);
        if (decoded &amp;&amp; decoded.iat &amp;&amp; decoded.iat * 1000 &lt; cutoff) {
          this.blacklistedTokens.delete(tokenId);
        }
      } catch (error) {
        // Remove invalid tokens
        this.blacklistedTokens.delete(tokenId);
      }
    }

    // Clear old login attempts
    for (const [key, attempts] of this.loginAttempts) {
      if (!attempts.lockedUntil || attempts.lockedUntil &lt; Date.now()) {
        this.loginAttempts.delete(key);
      }
    }

    this.emit('cleanupCompleted');
  }
}

/**
 * Express middleware for authentication
 */
export class AuthMiddleware {
  constructor(authManager) {
    this.authManager = authManager;
  }

  /**
   * JWT authentication middleware
   */
  authenticate(options = {}) {
    return (req, res, next) => {
      passport.authenticate('jwt', { session: false }, (err, user, info) => {
        if (err) {
          return next(err);
        }

        if (!user) {
          return res.status(401).json({
            error: 'Unauthorized',
            message: info?.message || 'Invalid or expired token'
          });
        }

        req.user = user;
        next();
      })(req, res, next);
    };
  }

  /**
   * API key authentication middleware
   */
  authenticateApiKey() {
    return async (req, res, next) => {
      try {
        const apiKey = req.headers['x-api-key'] || req.query.apiKey;
        
        if (!apiKey) {
          return res.status(401).json({
            error: 'Unauthorized',
            message: 'API key required'
          });
        }

        const result = await this.authManager.validateApiKey(apiKey);
        if (!result) {
          return res.status(401).json({
            error: 'Unauthorized',
            message: 'Invalid API key'
          });
        }

        req.user = result.user;
        req.apiKey = result.apiKey;
        req.userPermissions = result.permissions;
        next();
      } catch (error) {
        res.status(500).json({
          error: 'Authentication error',
          message: error.message
        });
      }
    };
  }

  /**
   * Permission check middleware
   */
  requirePermission(permission) {
    return (req, res, next) => {
      if (!req.user) {
        return res.status(401).json({
          error: 'Unauthorized',
          message: 'Authentication required'
        });
      }

      const hasPermission = this.authManager.hasPermission(req.user, permission);
      if (!hasPermission) {
        return res.status(403).json({
          error: 'Forbidden',
          message: `Insufficient permissions. Required: ${permission}`
        });
      }

      next();
    };
  }

  /**
   * Role-based access control
   */
  requireRole(roles) {
    const roleArray = Array.isArray(roles) ? roles : [roles];
    
    return (req, res, next) => {
      if (!req.user) {
        return res.status(401).json({
          error: 'Unauthorized',
          message: 'Authentication required'
        });
      }

      if (!roleArray.includes(req.user.role)) {
        return res.status(403).json({
          error: 'Forbidden',
          message: `Insufficient role. Required: ${roleArray.join(' or ')}, Have: ${req.user.role}`
        });
      }

      next();
    };
  }

  /**
   * Flexible authentication (JWT or API key)
   */
  authenticateFlexible() {
    return async (req, res, next) => {
      // Try JWT first
      const authHeader = req.headers.authorization;
      if (authHeader &amp;&amp; authHeader.startsWith('Bearer ')) {
        return this.authenticate()(req, res, next);
      }

      // Try API key
      const apiKey = req.headers['x-api-key'] || req.query.apiKey;
      if (apiKey) {
        return this.authenticateApiKey()(req, res, next);
      }

      res.status(401).json({
        error: 'Unauthorized',
        message: 'Authentication required (Bearer token or API key)'
      });
    };
  }
}

export default AuthenticationManager;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ABTestingManager.html">ABTestingManager</a></li><li><a href="AuditLogger.html">AuditLogger</a></li><li><a href="AuthMiddleware.html">AuthMiddleware</a></li><li><a href="BPETokenizer.html">BPETokenizer</a></li><li><a href="BaseEngine.html">BaseEngine</a></li><li><a href="BaseLoader.html">BaseLoader</a></li><li><a href="BinaryLoader.html">BinaryLoader</a></li><li><a href="BinaryModel.html">BinaryModel</a></li><li><a href="BitNetLoader.html">BitNetLoader</a></li><li><a href="ConversionConfig.html">ConversionConfig</a></li><li><a href="ConversionResult.html">ConversionResult</a></li><li><a href="EnterpriseAuthManager.html">EnterpriseAuthManager</a></li><li><a href="EnterpriseManager.html">EnterpriseManager</a></li><li><a href="EnterpriseRouter.html">EnterpriseRouter</a></li><li><a href="FormatConverter.html">FormatConverter</a></li><li><a href="GGUFLoader.html">GGUFLoader</a></li><li><a href="GGUFModel.html">GGUFModel</a></li><li><a href="GRPCClient.html">GRPCClient</a></li><li><a href="LLMRouter.html">LLMRouter</a></li><li><a href="MockLoader.html">MockLoader</a></li><li><a href="MockModel.html">MockModel</a></li><li><a href="ModelInterface.html">ModelInterface</a></li><li><a href="ModelQuantizer.html">ModelQuantizer</a></li><li><a href="ModelTemplates.html">ModelTemplates</a></li><li><a href="MultiTenancyManager.html">MultiTenancyManager</a></li><li><a href="PyTorchLoader.html">PyTorchLoader</a></li><li><a href="PyTorchModel.html">PyTorchModel</a></li><li><a href="QuantizationConfig.html">QuantizationConfig</a></li><li><a href="QuantizationResult.html">QuantizationResult</a></li><li><a href="Router.html">Router</a></li><li><a href="SLAMonitor.html">SLAMonitor</a></li><li><a href="SentencePieceTokenizer.html">SentencePieceTokenizer</a></li><li><a href="SimpleLoader.html">SimpleLoader</a></li><li><a href="SimpleModel.html">SimpleModel</a></li><li><a href="TokenizationResult.html">TokenizationResult</a></li><li><a href="TokenizerConfig.html">TokenizerConfig</a></li><li><a href="UniversalTokenizer.html">UniversalTokenizer</a></li><li><a href="ValidationConfig.html">ValidationConfig</a></li><li><a href="ValidationSuite.html">ValidationSuite</a></li><li><a href="ValidationSuiteResult.html">ValidationSuiteResult</a></li><li><a href="ValidationTestResult.html">ValidationTestResult</a></li><li><a href="WordPieceTokenizer.html">WordPieceTokenizer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Architectures">Architectures</a></li><li><a href="global.html#AuditEventTypes">AuditEventTypes</a></li><li><a href="global.html#AuthMethods">AuthMethods</a></li><li><a href="global.html#BreachSeverity">BreachSeverity</a></li><li><a href="global.html#Capabilities">Capabilities</a></li><li><a href="global.html#ComplianceFrameworks">ComplianceFrameworks</a></li><li><a href="global.html#EnterpriseFeatures">EnterpriseFeatures</a></li><li><a href="global.html#ExperimentStatus">ExperimentStatus</a></li><li><a href="global.html#IsolationLevels">IsolationLevels</a></li><li><a href="global.html#ModelFormat">ModelFormat</a></li><li><a href="global.html#ModelFormats">ModelFormats</a></li><li><a href="global.html#Permissions">Permissions</a></li><li><a href="global.html#QuantizationMethod">QuantizationMethod</a></li><li><a href="global.html#QuantizationPrecision">QuantizationPrecision</a></li><li><a href="global.html#QuotaTypes">QuotaTypes</a></li><li><a href="global.html#RiskLevels">RiskLevels</a></li><li><a href="global.html#RoutingStrategies">RoutingStrategies</a></li><li><a href="global.html#SLAMetricTypes">SLAMetricTypes</a></li><li><a href="global.html#SLAStatus">SLAStatus</a></li><li><a href="global.html#SessionTypes">SessionTypes</a></li><li><a href="global.html#SplittingAlgorithms">SplittingAlgorithms</a></li><li><a href="global.html#StatisticalTests">StatisticalTests</a></li><li><a href="global.html#TimeWindows">TimeWindows</a></li><li><a href="global.html#TokenizerType">TokenizerType</a></li><li><a href="global.html#UserRoles">UserRoles</a></li><li><a href="global.html#ValidationSeverity">ValidationSeverity</a></li><li><a href="global.html#ValidationTestType">ValidationTestType</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#createEnterpriseExpressRoutes">createEnterpriseExpressRoutes</a></li><li><a href="global.html#createEnterpriseRouter">createEnterpriseRouter</a></li><li><a href="global.html#createEnterpriseWebSocketHandlers">createEnterpriseWebSocketHandlers</a></li><li><a href="global.html#defaultEnterpriseConfig">defaultEnterpriseConfig</a></li><li><a href="global.html#enterpriseVersion">enterpriseVersion</a></li><li><a href="global.html#errorMonitoringMiddleware">errorMonitoringMiddleware</a></li><li><a href="global.html#getEnabledFeatures">getEnabledFeatures</a></li><li><a href="global.html#getMonitoringStatus">getMonitoringStatus</a></li><li><a href="global.html#httpMonitoringMiddleware">httpMonitoringMiddleware</a></li><li><a href="global.html#isFeatureEnabled">isFeatureEnabled</a></li><li><a href="global.html#recordCustomMetric">recordCustomMetric</a></li><li><a href="global.html#registerAlertRule">registerAlertRule</a></li><li><a href="global.html#registerDependency">registerDependency</a></li><li><a href="global.html#registerHealthCheck">registerHealthCheck</a></li><li><a href="global.html#setupMonitoring">setupMonitoring</a></li><li><a href="global.html#startPerformanceProfile">startPerformanceProfile</a></li><li><a href="global.html#validateEnterpriseConfig">validateEnterpriseConfig</a></li><li><a href="global.html#withCacheMonitoring">withCacheMonitoring</a></li><li><a href="global.html#withDatabaseMonitoring">withDatabaseMonitoring</a></li><li><a href="global.html#withModelMonitoring">withModelMonitoring</a></li><li><a href="global.html#withQueueMonitoring">withQueueMonitoring</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sun Aug 17 2025 22:28:58 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
