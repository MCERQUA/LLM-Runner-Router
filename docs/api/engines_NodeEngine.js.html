<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: engines/NodeEngine.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: engines/NodeEngine.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Node Engine
 * Optimized inference engine for Node.js with native bindings
 * Provides high-performance server-side model execution
 */

import { EventEmitter } from 'events';
import { Worker } from 'worker_threads';
import { cpus } from 'os';
import { Logger } from '../utils/Logger.js';

class NodeEngine extends EventEmitter {
  constructor(config = {}) {
    super();
    this.logger = new Logger('NodeEngine');
    this.config = {
      threads: config.threads || cpus().length,
      useNativeBindings: config.useNativeBindings !== false,
      enableSimd: config.enableSimd !== false,
      enableAvx: config.enableAvx !== false,
      memoryLimit: config.memoryLimit || 4096, // MB
      timeout: config.timeout || 30000, // ms
      workerPool: config.workerPool !== false
    };
    
    this.initialized = false;
    this.workers = [];
    this.workerQueue = [];
    this.activeJobs = new Map();
    this.capabilities = {};
  }

  /**
   * Initialize the engine
   */
  async initialize() {
    if (this.initialized) return true;
    
    try {
      this.logger.info('Initializing Node Engine');
      
      // Detect CPU capabilities
      this.capabilities = this.detectCapabilities();
      
      // Initialize worker pool if enabled
      if (this.config.workerPool) {
        await this.initializeWorkerPool();
      }
      
      // Check for native bindings
      if (this.config.useNativeBindings) {
        await this.loadNativeBindings();
      }
      
      this.initialized = true;
      this.logger.info(`Node Engine initialized with ${this.config.threads} threads`);
      
      return true;
    } catch (error) {
      this.logger.error(`Initialization failed: ${error.message}`);
      return false;
    }
  }

  /**
   * Detect CPU capabilities
   */
  detectCapabilities() {
    const caps = {
      cores: cpus().length,
      arch: process.arch,
      platform: process.platform,
      nodeVersion: process.version,
      hasSimd: false,
      hasAvx: false,
      hasAvx2: false,
      hasAvx512: false
    };
    
    // Check for SIMD/AVX support (simplified - would need native code for accurate detection)
    if (process.arch === 'x64' || process.arch === 'arm64') {
      caps.hasSimd = true;
      
      // x64 typically has AVX on modern CPUs
      if (process.arch === 'x64') {
        caps.hasAvx = true;
        // Assume AVX2 on newer systems
        const nodeVersionMajor = parseInt(process.version.split('.')[0].substring(1));
        if (nodeVersionMajor >= 14) {
          caps.hasAvx2 = true;
        }
      }
    }
    
    this.logger.info(`CPU capabilities: ${JSON.stringify(caps)}`);
    return caps;
  }

  /**
   * Initialize worker pool
   */
  async initializeWorkerPool() {
    const workerCount = Math.min(this.config.threads, cpus().length);
    
    for (let i = 0; i &lt; workerCount; i++) {
      const worker = await this.createWorker(i);
      this.workers.push(worker);
    }
    
    this.logger.info(`Worker pool initialized with ${workerCount} workers`);
  }

  /**
   * Create a worker thread
   */
  async createWorker(id) {
    return new Promise((resolve, reject) => {
      // Create inline worker code
      const workerCode = `
        const { parentPort } = require('worker_threads');
        
        parentPort.on('message', async (msg) => {
          try {
            let result;
            
            switch (msg.type) {
              case 'compute':
                result = await performComputation(msg.data);
                break;
              case 'transform':
                result = await performTransformation(msg.data);
                break;
              case 'inference':
                result = await performInference(msg.data);
                break;
              default:
                throw new Error('Unknown operation type: ' + msg.type);
            }
            
            parentPort.postMessage({
              id: msg.id,
              success: true,
              result
            });
          } catch (error) {
            parentPort.postMessage({
              id: msg.id,
              success: false,
              error: error.message
            });
          }
        });
        
        async function performComputation(data) {
          // Simulate computation
          const { input, operation } = data;
          
          switch (operation) {
            case 'matmul':
              return matrixMultiply(input.a, input.b);
            case 'conv2d':
              return convolution2d(input.tensor, input.kernel);
            case 'activation':
              return applyActivation(input.tensor, input.type);
            default:
              return input;
          }
        }
        
        async function performTransformation(data) {
          // Simulate tensor transformation
          const { tensor, shape } = data;
          return reshapeTensor(tensor, shape);
        }
        
        async function performInference(data) {
          // Simulate model inference
          const { modelId, input } = data;
          // In real implementation, would load and run model
          return {
            modelId,
            output: Array(10).fill(0).map(() => Math.random())
          };
        }
        
        function matrixMultiply(a, b) {
          // Simplified matrix multiplication
          if (!Array.isArray(a) || !Array.isArray(b)) return [];
          const result = [];
          for (let i = 0; i &lt; a.length; i++) {
            result[i] = [];
            for (let j = 0; j &lt; b[0].length; j++) {
              let sum = 0;
              for (let k = 0; k &lt; b.length; k++) {
                sum += a[i][k] * b[k][j];
              }
              result[i][j] = sum;
            }
          }
          return result;
        }
        
        function convolution2d(tensor, kernel) {
          // Simplified 2D convolution
          return tensor.map(row => row.map(val => val * kernel));
        }
        
        function applyActivation(tensor, type) {
          switch (type) {
            case 'relu':
              return tensor.map(val => Math.max(0, val));
            case 'sigmoid':
              return tensor.map(val => 1 / (1 + Math.exp(-val)));
            case 'tanh':
              return tensor.map(val => Math.tanh(val));
            default:
              return tensor;
          }
        }
        
        function reshapeTensor(tensor, shape) {
          // Simplified reshape
          return { data: tensor, shape };
        }
      `;
      
      const worker = new Worker(workerCode, { eval: true });
      
      worker.on('error', (error) => {
        this.logger.error(`Worker ${id} error: ${error.message}`);
        reject(error);
      });
      
      worker.on('exit', (code) => {
        if (code !== 0) {
          this.logger.error(`Worker ${id} exited with code ${code}`);
        }
      });
      
      worker.once('online', () => {
        worker.id = id;
        worker.busy = false;
        resolve(worker);
      });
    });
  }

  /**
   * Load native bindings
   */
  async loadNativeBindings() {
    try {
      // Check for various native binding libraries
      const bindings = [];
      
      // Try to load common native ML libraries
      // In real implementation, would check for actual native modules
      const nativeLibraries = [
        'node-llama-cpp',
        '@tensorflow/tfjs-node',
        'onnxruntime-node'
      ];
      
      for (const lib of nativeLibraries) {
        try {
          // Check if module exists (don't actually import to avoid errors)
          await import(lib).catch(() => null);
          bindings.push(lib);
        } catch {
          // Library not available
        }
      }
      
      if (bindings.length > 0) {
        this.logger.info(`Native bindings available: ${bindings.join(', ')}`);
      }
      
      return bindings;
    } catch (error) {
      this.logger.warn(`Could not load native bindings: ${error.message}`);
      return [];
    }
  }

  /**
   * Execute computation using the engine
   */
  async execute(operation, data) {
    if (!this.initialized) {
      await this.initialize();
    }
    
    // Use worker pool if available
    if (this.workers.length > 0) {
      return await this.executeWithWorker(operation, data);
    }
    
    // Otherwise execute in main thread
    return await this.executeInMainThread(operation, data);
  }

  /**
   * Execute with worker pool
   */
  async executeWithWorker(operation, data) {
    return new Promise((resolve, reject) => {
      const jobId = `job-${Date.now()}-${Math.random()}`;
      
      // Find available worker
      const worker = this.workers.find(w => !w.busy);
      
      if (!worker) {
        // Queue the job
        this.workerQueue.push({ jobId, operation, data, resolve, reject });
        return;
      }
      
      // Mark worker as busy
      worker.busy = true;
      
      // Set timeout
      const timeout = setTimeout(() => {
        worker.busy = false;
        reject(new Error('Worker timeout'));
      }, this.config.timeout);
      
      // Setup message handler
      const messageHandler = (msg) => {
        if (msg.id === jobId) {
          clearTimeout(timeout);
          worker.busy = false;
          worker.removeListener('message', messageHandler);
          
          // Process queued jobs
          this.processQueue();
          
          if (msg.success) {
            resolve(msg.result);
          } else {
            reject(new Error(msg.error));
          }
        }
      };
      
      worker.on('message', messageHandler);
      
      // Send job to worker
      worker.postMessage({
        id: jobId,
        type: operation,
        data
      });
    });
  }

  /**
   * Process queued jobs
   */
  processQueue() {
    if (this.workerQueue.length === 0) return;
    
    const availableWorker = this.workers.find(w => !w.busy);
    if (!availableWorker) return;
    
    const job = this.workerQueue.shift();
    if (job) {
      this.executeWithWorker(job.operation, job.data)
        .then(job.resolve)
        .catch(job.reject);
    }
  }

  /**
   * Execute in main thread
   */
  async executeInMainThread(operation, data) {
    try {
      switch (operation) {
        case 'compute':
          return await this.performComputation(data);
        case 'transform':
          return await this.performTransformation(data);
        case 'inference':
          return await this.performInference(data);
        default:
          throw new Error(`Unknown operation: ${operation}`);
      }
    } catch (error) {
      this.logger.error(`Execution failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * Perform computation
   */
  async performComputation(data) {
    const { input, operation } = data;
    
    // Use optimized implementations based on capabilities
    if (this.capabilities.hasAvx2 &amp;&amp; this.config.enableAvx) {
      return this.computeWithAvx(input, operation);
    } else if (this.capabilities.hasSimd &amp;&amp; this.config.enableSimd) {
      return this.computeWithSimd(input, operation);
    } else {
      return this.computeBasic(input, operation);
    }
  }

  /**
   * Basic computation
   */
  computeBasic(input, operation) {
    switch (operation) {
      case 'matmul':
        return this.matrixMultiply(input.a, input.b);
      case 'conv2d':
        return this.convolution2d(input.tensor, input.kernel);
      case 'activation':
        return this.applyActivation(input.tensor, input.type);
      default:
        return input;
    }
  }

  /**
   * SIMD-optimized computation (simulated)
   */
  computeWithSimd(input, operation) {
    // In real implementation, would use SIMD instructions
    this.logger.debug('Using SIMD optimization');
    return this.computeBasic(input, operation);
  }

  /**
   * AVX-optimized computation (simulated)
   */
  computeWithAvx(input, operation) {
    // In real implementation, would use AVX instructions
    this.logger.debug('Using AVX optimization');
    return this.computeBasic(input, operation);
  }

  /**
   * Matrix multiplication
   */
  matrixMultiply(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b)) return [];
    
    const result = [];
    for (let i = 0; i &lt; a.length; i++) {
      result[i] = [];
      for (let j = 0; j &lt; b[0].length; j++) {
        let sum = 0;
        for (let k = 0; k &lt; b.length; k++) {
          sum += a[i][k] * b[k][j];
        }
        result[i][j] = sum;
      }
    }
    return result;
  }

  /**
   * 2D Convolution
   */
  convolution2d(tensor, kernel) {
    // Simplified convolution
    return tensor.map(row => 
      row.map(val => val * (kernel || 1))
    );
  }

  /**
   * Apply activation function
   */
  applyActivation(tensor, type) {
    const flat = tensor.flat();
    let result;
    
    switch (type) {
      case 'relu':
        result = flat.map(val => Math.max(0, val));
        break;
      case 'sigmoid':
        result = flat.map(val => 1 / (1 + Math.exp(-val)));
        break;
      case 'tanh':
        result = flat.map(val => Math.tanh(val));
        break;
      case 'softmax':
        const expSum = flat.reduce((sum, val) => sum + Math.exp(val), 0);
        result = flat.map(val => Math.exp(val) / expSum);
        break;
      default:
        result = flat;
    }
    
    return result;
  }

  /**
   * Perform transformation
   */
  async performTransformation(data) {
    const { tensor, shape } = data;
    return { data: tensor, shape };
  }

  /**
   * Perform inference
   */
  async performInference(data) {
    const { modelId, input } = data;
    
    // Simulate inference with optimization
    const startTime = Date.now();
    
    // In real implementation, would run actual model
    const output = Array(10).fill(0).map(() => Math.random());
    
    const duration = Date.now() - startTime;
    
    return {
      modelId,
      output,
      duration,
      engine: 'node',
      threads: this.config.threads
    };
  }

  /**
   * Get engine info
   */
  getInfo() {
    return {
      name: 'NodeEngine',
      initialized: this.initialized,
      capabilities: this.capabilities,
      config: this.config,
      workers: this.workers.length,
      queueLength: this.workerQueue.length
    };
  }

  /**
   * Cleanup resources
   */
  async cleanup() {
    this.logger.info('Cleaning up Node Engine');
    
    // Terminate all workers
    for (const worker of this.workers) {
      await worker.terminate();
    }
    
    this.workers = [];
    this.workerQueue = [];
    this.activeJobs.clear();
    this.initialized = false;
  }
}
export default NodeEngine;
export { NodeEngine };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ABTestingManager.html">ABTestingManager</a></li><li><a href="APILoader.html">APILoader</a></li><li><a href="AnthropicAdapter.html">AnthropicAdapter</a></li><li><a href="AuditLogger.html">AuditLogger</a></li><li><a href="AuthManager.html">AuthManager</a></li><li><a href="AuthMiddleware.html">AuthMiddleware</a></li><li><a href="AzureOpenAIAdapter.html">AzureOpenAIAdapter</a></li><li><a href="BPETokenizer.html">BPETokenizer</a></li><li><a href="BaseEngine.html">BaseEngine</a></li><li><a href="BaseLoader.html">BaseLoader</a></li><li><a href="BedrockAdapter.html">BedrockAdapter</a></li><li><a href="BinaryLoader.html">BinaryLoader</a></li><li><a href="BinaryModel.html">BinaryModel</a></li><li><a href="BitNetLoader.html">BitNetLoader</a></li><li><a href="CohereAdapter.html">CohereAdapter</a></li><li><a href="ConversionConfig.html">ConversionConfig</a></li><li><a href="ConversionResult.html">ConversionResult</a></li><li><a href="DeepSeekAdapter.html">DeepSeekAdapter</a></li><li><a href="EnterpriseAuthManager.html">EnterpriseAuthManager</a></li><li><a href="EnterpriseManager.html">EnterpriseManager</a></li><li><a href="EnterpriseRouter.html">EnterpriseRouter</a></li><li><a href="ErrorHandler.html">ErrorHandler</a></li><li><a href="FireworksAdapter.html">FireworksAdapter</a></li><li><a href="FormatConverter.html">FormatConverter</a></li><li><a href="GGUFLoader.html">GGUFLoader</a></li><li><a href="GGUFModel.html">GGUFModel</a></li><li><a href="GRPCClient.html">GRPCClient</a></li><li><a href="GroqAdapter.html">GroqAdapter</a></li><li><a href="LLMRouter.html">LLMRouter</a></li><li><a href="MistralAdapter.html">MistralAdapter</a></li><li><a href="MockLoader.html">MockLoader</a></li><li><a href="MockModel.html">MockModel</a></li><li><a href="ModelError.html">ModelError</a></li><li><a href="ModelInterface.html">ModelInterface</a></li><li><a href="ModelQuantizer.html">ModelQuantizer</a></li><li><a href="ModelRegistry.html">ModelRegistry</a></li><li><a href="ModelTemplates.html">ModelTemplates</a></li><li><a href="MultiTenancyManager.html">MultiTenancyManager</a></li><li><a href="NovitaAdapter.html">NovitaAdapter</a></li><li><a href="OpenAIAdapter.html">OpenAIAdapter</a></li><li><a href="OpenRouterAdapter.html">OpenRouterAdapter</a></li><li><a href="PerplexityAdapter.html">PerplexityAdapter</a></li><li><a href="Pipeline.html">Pipeline</a></li><li><a href="PyTorchLoader.html">PyTorchLoader</a></li><li><a href="PyTorchModel.html">PyTorchModel</a></li><li><a href="QuantizationConfig.html">QuantizationConfig</a></li><li><a href="QuantizationResult.html">QuantizationResult</a></li><li><a href="Router.html">Router</a></li><li><a href="SLAMonitor.html">SLAMonitor</a></li><li><a href="SentencePieceTokenizer.html">SentencePieceTokenizer</a></li><li><a href="SimpleLoader.html">SimpleLoader</a></li><li><a href="SimpleModel.html">SimpleModel</a></li><li><a href="TogetherAdapter.html">TogetherAdapter</a></li><li><a href="TokenizationResult.html">TokenizationResult</a></li><li><a href="TokenizerConfig.html">TokenizerConfig</a></li><li><a href="UniversalTokenizer.html">UniversalTokenizer</a></li><li><a href="ValidationConfig.html">ValidationConfig</a></li><li><a href="ValidationSuite.html">ValidationSuite</a></li><li><a href="ValidationSuiteResult.html">ValidationSuiteResult</a></li><li><a href="ValidationTestResult.html">ValidationTestResult</a></li><li><a href="VertexAIAdapter.html">VertexAIAdapter</a></li><li><a href="WordPieceTokenizer.html">WordPieceTokenizer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ADAPTER_REGISTRY">ADAPTER_REGISTRY</a></li><li><a href="global.html#API_KEY_PATTERNS">API_KEY_PATTERNS</a></li><li><a href="global.html#AUTH_TYPES">AUTH_TYPES</a></li><li><a href="global.html#AZURE_API_VERSIONS">AZURE_API_VERSIONS</a></li><li><a href="global.html#AZURE_OPENAI_MODELS">AZURE_OPENAI_MODELS</a></li><li><a href="global.html#Architectures">Architectures</a></li><li><a href="global.html#AuditEventTypes">AuditEventTypes</a></li><li><a href="global.html#AuthMethods">AuthMethods</a></li><li><a href="global.html#BEDROCK_MODELS">BEDROCK_MODELS</a></li><li><a href="global.html#BreachSeverity">BreachSeverity</a></li><li><a href="global.html#CLAUDE_MODELS">CLAUDE_MODELS</a></li><li><a href="global.html#COHERE_MODELS">COHERE_MODELS</a></li><li><a href="global.html#COMPLIANCE_FEATURES">COMPLIANCE_FEATURES</a></li><li><a href="global.html#Capabilities">Capabilities</a></li><li><a href="global.html#ComplianceFrameworks">ComplianceFrameworks</a></li><li><a href="global.html#DEEPSEEK_ENDPOINTS">DEEPSEEK_ENDPOINTS</a></li><li><a href="global.html#DEEPSEEK_MODELS">DEEPSEEK_MODELS</a></li><li><a href="global.html#EnterpriseFeatures">EnterpriseFeatures</a></li><li><a href="global.html#ExperimentStatus">ExperimentStatus</a></li><li><a href="global.html#FIREWORKS_MODELS">FIREWORKS_MODELS</a></li><li><a href="global.html#GROQ_MODELS">GROQ_MODELS</a></li><li><a href="global.html#INPUT_TYPES">INPUT_TYPES</a></li><li><a href="global.html#IsolationLevels">IsolationLevels</a></li><li><a href="global.html#MISTRAL_MODELS">MISTRAL_MODELS</a></li><li><a href="global.html#MODEL_CATEGORIES">MODEL_CATEGORIES</a></li><li><a href="global.html#ModelFormat">ModelFormat</a></li><li><a href="global.html#ModelFormats">ModelFormats</a></li><li><a href="global.html#NOVITA_ENDPOINTS">NOVITA_ENDPOINTS</a></li><li><a href="global.html#NOVITA_MODELS">NOVITA_MODELS</a></li><li><a href="global.html#OPENAI_MODELS">OPENAI_MODELS</a></li><li><a href="global.html#PERPLEXITY_MODELS">PERPLEXITY_MODELS</a></li><li><a href="global.html#POPULAR_MODELS">POPULAR_MODELS</a></li><li><a href="global.html#PROVIDER_AUTH_CONFIG">PROVIDER_AUTH_CONFIG</a></li><li><a href="global.html#PROVIDER_CATEGORIES">PROVIDER_CATEGORIES</a></li><li><a href="global.html#PROVIDER_CONFIGS">PROVIDER_CONFIGS</a></li><li><a href="global.html#PROVIDER_FEATURES">PROVIDER_FEATURES</a></li><li><a href="global.html#Permissions">Permissions</a></li><li><a href="global.html#QuantizationMethod">QuantizationMethod</a></li><li><a href="global.html#QuantizationPrecision">QuantizationPrecision</a></li><li><a href="global.html#QuotaTypes">QuotaTypes</a></li><li><a href="global.html#RiskLevels">RiskLevels</a></li><li><a href="global.html#RoutingStrategies">RoutingStrategies</a></li><li><a href="global.html#SAFETY_LEVELS">SAFETY_LEVELS</a></li><li><a href="global.html#SLAMetricTypes">SLAMetricTypes</a></li><li><a href="global.html#SLAStatus">SLAStatus</a></li><li><a href="global.html#SessionTypes">SessionTypes</a></li><li><a href="global.html#SplittingAlgorithms">SplittingAlgorithms</a></li><li><a href="global.html#StatisticalTests">StatisticalTests</a></li><li><a href="global.html#TOGETHER_MODELS">TOGETHER_MODELS</a></li><li><a href="global.html#TimeWindows">TimeWindows</a></li><li><a href="global.html#TokenizerType">TokenizerType</a></li><li><a href="global.html#UserRoles">UserRoles</a></li><li><a href="global.html#VERTEX_AI_MODELS">VERTEX_AI_MODELS</a></li><li><a href="global.html#VERTEX_REGIONS">VERTEX_REGIONS</a></li><li><a href="global.html#ValidationSeverity">ValidationSeverity</a></li><li><a href="global.html#ValidationTestType">ValidationTestType</a></li><li><a href="global.html#adjustTimeouts">adjustTimeouts</a></li><li><a href="global.html#attemptRecovery">attemptRecovery</a></li><li><a href="global.html#checkConnectivity">checkConnectivity</a></li><li><a href="global.html#clearCache">clearCache</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#createAdapter">createAdapter</a></li><li><a href="global.html#createEnterpriseExpressRoutes">createEnterpriseExpressRoutes</a></li><li><a href="global.html#createEnterpriseRouter">createEnterpriseRouter</a></li><li><a href="global.html#createEnterpriseWebSocketHandlers">createEnterpriseWebSocketHandlers</a></li><li><a href="global.html#createMissingResources">createMissingResources</a></li><li><a href="global.html#defaultEnterpriseConfig">defaultEnterpriseConfig</a></li><li><a href="global.html#emergencyShutdown">emergencyShutdown</a></li><li><a href="global.html#enterpriseVersion">enterpriseVersion</a></li><li><a href="global.html#errorMonitoringMiddleware">errorMonitoringMiddleware</a></li><li><a href="global.html#escalateError">escalateError</a></li><li><a href="global.html#executeRecovery">executeRecovery</a></li><li><a href="global.html#getAdapter">getAdapter</a></li><li><a href="global.html#getEnabledFeatures">getEnabledFeatures</a></li><li><a href="global.html#getMonitoringStatus">getMonitoringStatus</a></li><li><a href="global.html#getProviderAuthType">getProviderAuthType</a></li><li><a href="global.html#getProviderInfo">getProviderInfo</a></li><li><a href="global.html#getProvidersByCategory">getProvidersByCategory</a></li><li><a href="global.html#getProvidersByFeature">getProvidersByFeature</a></li><li><a href="global.html#getStats">getStats</a></li><li><a href="global.html#getSupportedProviders">getSupportedProviders</a></li><li><a href="global.html#gracefulShutdown">gracefulShutdown</a></li><li><a href="global.html#handleCriticalError">handleCriticalError</a></li><li><a href="global.html#handleMemoryLeak">handleMemoryLeak</a></li><li><a href="global.html#httpMonitoringMiddleware">httpMonitoringMiddleware</a></li><li><a href="global.html#isFeatureEnabled">isFeatureEnabled</a></li><li><a href="global.html#isProviderSupported">isProviderSupported</a></li><li><a href="global.html#logError">logError</a></li><li><a href="global.html#performHealthCheck">performHealthCheck</a></li><li><a href="global.html#recordCustomMetric">recordCustomMetric</a></li><li><a href="global.html#registerAlertRule">registerAlertRule</a></li><li><a href="global.html#registerDependency">registerDependency</a></li><li><a href="global.html#registerHealthCheck">registerHealthCheck</a></li><li><a href="global.html#reinstallDependencies">reinstallDependencies</a></li><li><a href="global.html#reload">reload</a></li><li><a href="global.html#restartProcess">restartProcess</a></li><li><a href="global.html#retryConnection">retryConnection</a></li><li><a href="global.html#selectRecoveryStrategy">selectRecoveryStrategy</a></li><li><a href="global.html#setupHandlers">setupHandlers</a></li><li><a href="global.html#setupMonitoring">setupMonitoring</a></li><li><a href="global.html#softRestart">softRestart</a></li><li><a href="global.html#startHealthMonitoring">startHealthMonitoring</a></li><li><a href="global.html#startPerformanceProfile">startPerformanceProfile</a></li><li><a href="global.html#validateEnterpriseConfig">validateEnterpriseConfig</a></li><li><a href="global.html#withCacheMonitoring">withCacheMonitoring</a></li><li><a href="global.html#withDatabaseMonitoring">withDatabaseMonitoring</a></li><li><a href="global.html#withModelMonitoring">withModelMonitoring</a></li><li><a href="global.html#withQueueMonitoring">withQueueMonitoring</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Aug 20 2025 19:41:21 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
