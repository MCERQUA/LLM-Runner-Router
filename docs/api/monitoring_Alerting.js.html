<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: monitoring/Alerting.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: monitoring/Alerting.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * ðŸš¨ Alerting System - Intelligent Notification Engine
 * Multi-channel alerting with escalation policies and smart aggregation
 * Echo AI Systems - Never miss what matters
 */

import EventEmitter from 'events';
import { promises as fs } from 'fs';
import Logger from '../utils/Logger.js';

class AlertingSystem extends EventEmitter {
  constructor(config = {}) {
    super();
    this.logger = new Logger('Alerting');
    this.config = {
      enabled: config.enabled ?? true,
      defaultSeverity: config.defaultSeverity || 'warning',
      aggregationWindow: config.aggregationWindow || 300000, // 5 minutes
      escalationDelay: config.escalationDelay || 900000, // 15 minutes
      maxRetries: config.maxRetries || 3,
      retryDelay: config.retryDelay || 5000, // 5 seconds
      
      // Alert channels configuration
      channels: {
        email: {
          enabled: config.channels?.email?.enabled ?? false,
          smtp: config.channels?.email?.smtp || {},
          from: config.channels?.email?.from || 'alerts@llm-router.local',
          to: config.channels?.email?.to || [],
        },
        slack: {
          enabled: config.channels?.slack?.enabled ?? false,
          webhookUrl: config.channels?.slack?.webhookUrl || '',
          channel: config.channels?.slack?.channel || '#alerts',
          username: config.channels?.slack?.username || 'LLM Router',
        },
        webhook: {
          enabled: config.channels?.webhook?.enabled ?? false,
          urls: config.channels?.webhook?.urls || [],
          headers: config.channels?.webhook?.headers || {},
        },
        pagerduty: {
          enabled: config.channels?.pagerduty?.enabled ?? false,
          routingKey: config.channels?.pagerduty?.routingKey || '',
          apiUrl: config.channels?.pagerduty?.apiUrl || 'https://events.pagerduty.com/v2/enqueue',
        },
        ...config.channels,
      },
      
      // Alert rules configuration
      rules: config.rules || [],
      
      // Storage configuration
      storage: {
        enabled: config.storage?.enabled ?? true,
        maxHistory: config.storage?.maxHistory || 10000,
        persistInterval: config.storage?.persistInterval || 60000, // 1 minute
        filePath: config.storage?.filePath || './alerts.json',
      },
      
      ...config,
    };

    this.alerts = new Map();
    this.alertHistory = [];
    this.aggregatedAlerts = new Map();
    this.escalationTimers = new Map();
    this.rules = new Map();
    this.isRunning = false;
    
    this._loadRules();
    this._setupPeriodicTasks();
  }

  /**
   * Load alert rules from configuration
   */
  _loadRules() {
    this.config.rules.forEach(rule => {
      this.addRule(rule.id, rule);
    });
    
    // Add default rules
    this._addDefaultRules();
  }

  /**
   * Add default alerting rules
   */
  _addDefaultRules() {
    // High error rate rule
    this.addRule('high_error_rate', {
      name: 'High Error Rate',
      description: 'Alert when error rate exceeds threshold',
      severity: 'critical',
      condition: (metrics) => {
        const errorRate = metrics.errorRate || 0;
        return errorRate > 0.05; // 5%
      },
      channels: ['slack', 'email'],
      aggregationKey: 'error_rate',
      escalation: true,
    });

    // High memory usage rule
    this.addRule('high_memory_usage', {
      name: 'High Memory Usage',
      description: 'Alert when memory usage exceeds threshold',
      severity: 'warning',
      condition: (metrics) => {
        const memoryUsage = metrics.memoryUsage || 0;
        return memoryUsage > 0.85; // 85%
      },
      channels: ['slack'],
      aggregationKey: 'memory_usage',
    });

    // Model inference failures
    this.addRule('model_inference_failures', {
      name: 'Model Inference Failures',
      description: 'Alert when model inference fails repeatedly',
      severity: 'critical',
      condition: (metrics) => {
        const failureRate = metrics.modelFailureRate || 0;
        return failureRate > 0.1; // 10%
      },
      channels: ['slack', 'pagerduty'],
      aggregationKey: 'model_failures',
      escalation: true,
    });

    // System health degradation
    this.addRule('system_health_degraded', {
      name: 'System Health Degraded',
      description: 'Alert when system health is degraded',
      severity: 'warning',
      condition: (metrics) => {
        return metrics.healthStatus === 'degraded' || metrics.healthStatus === 'unhealthy';
      },
      channels: ['slack'],
      aggregationKey: 'health_status',
    });

    // Performance degradation
    this.addRule('performance_degradation', {
      name: 'Performance Degradation',
      description: 'Alert when response times are consistently high',
      severity: 'warning',
      condition: (metrics) => {
        const avgResponseTime = metrics.avgResponseTime || 0;
        return avgResponseTime > 5000; // 5 seconds
      },
      channels: ['slack'],
      aggregationKey: 'performance',
    });

    this.logger.info('Default alert rules loaded');
  }

  /**
   * Setup periodic tasks
   */
  _setupPeriodicTasks() {
    // Periodic alert processing
    setInterval(() => {
      if (this.isRunning) {
        this._processAggregatedAlerts();
        this._cleanupOldAlerts();
      }
    }, 60000); // Every minute

    // Periodic storage persistence
    if (this.config.storage.enabled) {
      setInterval(() => {
        if (this.isRunning) {
          this._persistAlerts();
        }
      }, this.config.storage.persistInterval);
    }
  }

  /**
   * Start the alerting system
   */
  async start() {
    if (this.isRunning) {
      this.logger.warn('Alerting system already running');
      return;
    }

    this.isRunning = true;
    this.logger.info('Starting alerting system');

    // Load persisted alerts
    if (this.config.storage.enabled) {
      await this._loadPersistedAlerts();
    }

    this.emit('started');
  }

  /**
   * Stop the alerting system
   */
  async stop() {
    if (!this.isRunning) {
      return;
    }

    this.isRunning = false;
    this.logger.info('Stopping alerting system');

    // Clear escalation timers
    for (const timer of this.escalationTimers.values()) {
      clearTimeout(timer);
    }
    this.escalationTimers.clear();

    // Persist final state
    if (this.config.storage.enabled) {
      await this._persistAlerts();
    }

    this.emit('stopped');
  }

  /**
   * Add an alert rule
   */
  addRule(id, rule) {
    this.rules.set(id, {
      id,
      enabled: true,
      ...rule,
    });
    
    this.logger.info(`Alert rule added: ${id}`);
  }

  /**
   * Remove an alert rule
   */
  removeRule(id) {
    if (this.rules.delete(id)) {
      this.logger.info(`Alert rule removed: ${id}`);
      return true;
    }
    return false;
  }

  /**
   * Enable/disable an alert rule
   */
  toggleRule(id, enabled) {
    const rule = this.rules.get(id);
    if (rule) {
      rule.enabled = enabled;
      this.logger.info(`Alert rule ${id} ${enabled ? 'enabled' : 'disabled'}`);
      return true;
    }
    return false;
  }

  /**
   * Evaluate metrics against all rules
   */
  evaluateMetrics(metrics) {
    if (!this.config.enabled || !this.isRunning) {
      return;
    }

    for (const [ruleId, rule] of this.rules) {
      if (!rule.enabled) continue;

      try {
        if (rule.condition(metrics)) {
          this.triggerAlert(ruleId, {
            message: rule.description,
            severity: rule.severity,
            metrics,
            rule,
          });
        }
      } catch (error) {
        this.logger.error(`Error evaluating rule ${ruleId}:`, error);
      }
    }
  }

  /**
   * Trigger an alert
   */
  async triggerAlert(ruleId, alertData) {
    const rule = this.rules.get(ruleId);
    if (!rule) {
      this.logger.error(`Unknown rule: ${ruleId}`);
      return;
    }

    const alertId = `${ruleId}_${Date.now()}`;
    const alert = {
      id: alertId,
      ruleId,
      timestamp: new Date(),
      severity: alertData.severity || rule.severity || this.config.defaultSeverity,
      message: alertData.message || rule.description,
      data: alertData,
      rule,
      status: 'active',
      notificationsSent: [],
      escalated: false,
    };

    // Check for aggregation
    if (rule.aggregationKey) {
      this._aggregateAlert(rule.aggregationKey, alert);
      return;
    }

    // Process alert immediately
    await this._processAlert(alert);
  }

  /**
   * Aggregate similar alerts
   */
  _aggregateAlert(aggregationKey, alert) {
    if (!this.aggregatedAlerts.has(aggregationKey)) {
      this.aggregatedAlerts.set(aggregationKey, {
        key: aggregationKey,
        alerts: [],
        firstAlert: alert,
        lastAlert: alert,
        count: 0,
        processed: false,
      });

      // Schedule processing after aggregation window
      setTimeout(() => {
        this._processAggregatedAlert(aggregationKey);
      }, this.config.aggregationWindow);
    }

    const aggregated = this.aggregatedAlerts.get(aggregationKey);
    aggregated.alerts.push(alert);
    aggregated.lastAlert = alert;
    aggregated.count++;
  }

  /**
   * Process aggregated alerts
   */
  _processAggregatedAlerts() {
    for (const [key, aggregated] of this.aggregatedAlerts) {
      if (!aggregated.processed &amp;&amp; Date.now() - aggregated.firstAlert.timestamp.getTime() >= this.config.aggregationWindow) {
        this._processAggregatedAlert(key);
      }
    }
  }

  /**
   * Process a single aggregated alert
   */
  async _processAggregatedAlert(aggregationKey) {
    const aggregated = this.aggregatedAlerts.get(aggregationKey);
    if (!aggregated || aggregated.processed) return;

    aggregated.processed = true;

    const alert = {
      ...aggregated.firstAlert,
      id: `aggregated_${aggregationKey}_${Date.now()}`,
      message: aggregated.count > 1 
        ? `${aggregated.firstAlert.message} (${aggregated.count} occurrences)`
        : aggregated.firstAlert.message,
      aggregated: true,
      aggregationData: {
        key: aggregationKey,
        count: aggregated.count,
        timespan: aggregated.lastAlert.timestamp.getTime() - aggregated.firstAlert.timestamp.getTime(),
      },
    };

    await this._processAlert(alert);

    // Clean up aggregated alerts
    this.aggregatedAlerts.delete(aggregationKey);
  }

  /**
   * Process an individual alert
   */
  async _processAlert(alert) {
    this.alerts.set(alert.id, alert);
    this.alertHistory.push(alert);

    this.logger.warn(`Alert triggered: ${alert.message}`, {
      severity: alert.severity,
      ruleId: alert.ruleId,
    });

    // Send notifications
    await this._sendNotifications(alert);

    // Setup escalation if configured
    if (alert.rule.escalation &amp;&amp; !alert.escalated) {
      this._setupEscalation(alert);
    }

    this.emit('alert', alert);
  }

  /**
   * Send notifications for an alert
   */
  async _sendNotifications(alert) {
    const channels = alert.rule.channels || ['slack'];
    
    for (const channelName of channels) {
      if (!this.config.channels[channelName]?.enabled) {
        continue;
      }

      try {
        await this._sendNotification(channelName, alert);
        alert.notificationsSent.push({
          channel: channelName,
          timestamp: new Date(),
          status: 'success',
        });
      } catch (error) {
        this.logger.error(`Failed to send ${channelName} notification:`, error);
        alert.notificationsSent.push({
          channel: channelName,
          timestamp: new Date(),
          status: 'failed',
          error: error.message,
        });
      }
    }
  }

  /**
   * Send notification to specific channel
   */
  async _sendNotification(channelName, alert) {
    switch (channelName) {
      case 'slack':
        return this._sendSlackNotification(alert);
      case 'email':
        return this._sendEmailNotification(alert);
      case 'webhook':
        return this._sendWebhookNotification(alert);
      case 'pagerduty':
        return this._sendPagerDutyNotification(alert);
      default:
        throw new Error(`Unknown notification channel: ${channelName}`);
    }
  }

  /**
   * Send Slack notification
   */
  async _sendSlackNotification(alert) {
    const config = this.config.channels.slack;
    if (!config.webhookUrl) {
      throw new Error('Slack webhook URL not configured');
    }

    const emoji = this._getSeverityEmoji(alert.severity);
    const color = this._getSeverityColor(alert.severity);
    
    const payload = {
      channel: config.channel,
      username: config.username,
      icon_emoji: emoji,
      attachments: [{
        color,
        title: `${emoji} ${alert.severity.toUpperCase()} Alert`,
        text: alert.message,
        fields: [
          {
            title: 'Rule',
            value: alert.ruleId,
            short: true,
          },
          {
            title: 'Timestamp',
            value: alert.timestamp.toISOString(),
            short: true,
          },
        ],
        footer: 'LLM Router Monitoring',
        ts: Math.floor(alert.timestamp.getTime() / 1000),
      }],
    };

    if (alert.aggregated) {
      payload.attachments[0].fields.push({
        title: 'Occurrences',
        value: alert.aggregationData.count.toString(),
        short: true,
      });
    }

    const response = await fetch(config.webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`Slack API error: ${response.status}`);
    }
  }

  /**
   * Send email notification
   */
  async _sendEmailNotification(alert) {
    const config = this.config.channels.email;
    
    // Email implementation would require a proper email library like nodemailer
    // This is a placeholder for the structure
    const emailData = {
      from: config.from,
      to: config.to,
      subject: `[${alert.severity.toUpperCase()}] ${alert.message}`,
      html: this._generateEmailHTML(alert),
    };

    // Placeholder for actual email sending
    this.logger.info('Email notification would be sent:', emailData);
  }

  /**
   * Send webhook notification
   */
  async _sendWebhookNotification(alert) {
    const config = this.config.channels.webhook;
    
    const payload = {
      alert,
      timestamp: alert.timestamp.toISOString(),
      severity: alert.severity,
      message: alert.message,
    };

    for (const url of config.urls) {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...config.headers,
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`Webhook error: ${response.status}`);
      }
    }
  }

  /**
   * Send PagerDuty notification
   */
  async _sendPagerDutyNotification(alert) {
    const config = this.config.channels.pagerduty;
    if (!config.routingKey) {
      throw new Error('PagerDuty routing key not configured');
    }

    const payload = {
      routing_key: config.routingKey,
      event_action: 'trigger',
      dedup_key: alert.ruleId,
      payload: {
        summary: alert.message,
        severity: alert.severity,
        source: 'llm-router',
        timestamp: alert.timestamp.toISOString(),
        custom_details: {
          rule_id: alert.ruleId,
          alert_id: alert.id,
          aggregated: alert.aggregated || false,
        },
      },
    };

    const response = await fetch(config.apiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`PagerDuty API error: ${response.status}`);
    }
  }

  /**
   * Setup escalation for an alert
   */
  _setupEscalation(alert) {
    const timer = setTimeout(async () => {
      if (this.alerts.has(alert.id) &amp;&amp; !alert.escalated) {
        alert.escalated = true;
        alert.severity = this._escalateSeverity(alert.severity);
        
        this.logger.warn(`Alert escalated: ${alert.id}`, {
          newSeverity: alert.severity,
        });

        // Send escalated notifications
        await this._sendNotifications(alert);
        
        this.emit('alert-escalated', alert);
      }
      
      this.escalationTimers.delete(alert.id);
    }, this.config.escalationDelay);

    this.escalationTimers.set(alert.id, timer);
  }

  /**
   * Escalate severity level
   */
  _escalateSeverity(currentSeverity) {
    const escalationMap = {
      'info': 'warning',
      'warning': 'critical',
      'critical': 'critical', // Already at highest level
    };
    
    return escalationMap[currentSeverity] || 'critical';
  }

  /**
   * Get emoji for severity level
   */
  _getSeverityEmoji(severity) {
    const emojiMap = {
      'info': ':information_source:',
      'warning': ':warning:',
      'critical': ':rotating_light:',
    };
    
    return emojiMap[severity] || ':question:';
  }

  /**
   * Get color for severity level
   */
  _getSeverityColor(severity) {
    const colorMap = {
      'info': '#36a64f',
      'warning': '#ff9500',
      'critical': '#ff0000',
    };
    
    return colorMap[severity] || '#808080';
  }

  /**
   * Generate email HTML
   */
  _generateEmailHTML(alert) {
    return `
      &lt;html>
        &lt;body>
          &lt;h2>Alert: ${alert.message}&lt;/h2>
          &lt;p>&lt;strong>Severity:&lt;/strong> ${alert.severity}&lt;/p>
          &lt;p>&lt;strong>Rule:&lt;/strong> ${alert.ruleId}&lt;/p>
          &lt;p>&lt;strong>Timestamp:&lt;/strong> ${alert.timestamp.toISOString()}&lt;/p>
          ${alert.aggregated ? `&lt;p>&lt;strong>Occurrences:&lt;/strong> ${alert.aggregationData.count}&lt;/p>` : ''}
          &lt;hr>
          &lt;p>&lt;em>LLM Router Monitoring System&lt;/em>&lt;/p>
        &lt;/body>
      &lt;/html>
    `;
  }

  /**
   * Resolve an alert
   */
  resolveAlert(alertId) {
    const alert = this.alerts.get(alertId);
    if (alert) {
      alert.status = 'resolved';
      alert.resolvedAt = new Date();
      
      // Clear escalation timer
      const timer = this.escalationTimers.get(alertId);
      if (timer) {
        clearTimeout(timer);
        this.escalationTimers.delete(alertId);
      }
      
      this.logger.info(`Alert resolved: ${alertId}`);
      this.emit('alert-resolved', alert);
      
      return true;
    }
    
    return false;
  }

  /**
   * Clean up old alerts
   */
  _cleanupOldAlerts() {
    const maxAge = 24 * 60 * 60 * 1000; // 24 hours
    const cutoff = Date.now() - maxAge;
    
    let removed = 0;
    for (const [alertId, alert] of this.alerts) {
      if (alert.timestamp.getTime() &lt; cutoff) {
        this.alerts.delete(alertId);
        removed++;
      }
    }
    
    // Clean up history
    this.alertHistory = this.alertHistory.filter(alert => 
      alert.timestamp.getTime() > cutoff
    );
    
    if (this.alertHistory.length > this.config.storage.maxHistory) {
      this.alertHistory = this.alertHistory.slice(-this.config.storage.maxHistory);
    }
    
    if (removed > 0) {
      this.logger.debug(`Cleaned up ${removed} old alerts`);
    }
  }

  /**
   * Persist alerts to storage
   */
  async _persistAlerts() {
    try {
      const data = {
        alerts: Object.fromEntries(this.alerts),
        history: this.alertHistory.slice(-1000), // Last 1000 alerts
        timestamp: new Date(),
      };
      
      await fs.writeFile(this.config.storage.filePath, JSON.stringify(data, null, 2));
    } catch (error) {
      this.logger.error('Failed to persist alerts:', error);
    }
  }

  /**
   * Load persisted alerts
   */
  async _loadPersistedAlerts() {
    try {
      const data = await fs.readFile(this.config.storage.filePath, 'utf8');
      const parsed = JSON.parse(data);
      
      // Restore alerts
      for (const [id, alert] of Object.entries(parsed.alerts || {})) {
        this.alerts.set(id, {
          ...alert,
          timestamp: new Date(alert.timestamp),
        });
      }
      
      // Restore history
      this.alertHistory = (parsed.history || []).map(alert => ({
        ...alert,
        timestamp: new Date(alert.timestamp),
      }));
      
      this.logger.info(`Loaded ${this.alerts.size} persisted alerts`);
    } catch (error) {
      if (error.code !== 'ENOENT') {
        this.logger.error('Failed to load persisted alerts:', error);
      }
    }
  }

  /**
   * Get alert statistics
   */
  getAlertStats() {
    const now = Date.now();
    const oneHour = 60 * 60 * 1000;
    const oneDay = 24 * oneHour;
    
    const recentHistory = this.alertHistory.filter(alert => 
      now - alert.timestamp.getTime() &lt; oneDay
    );
    
    const severityCounts = recentHistory.reduce((counts, alert) => {
      counts[alert.severity] = (counts[alert.severity] || 0) + 1;
      return counts;
    }, {});
    
    return {
      active: this.alerts.size,
      totalHistory: this.alertHistory.length,
      last24Hours: recentHistory.length,
      lastHour: recentHistory.filter(alert => 
        now - alert.timestamp.getTime() &lt; oneHour
      ).length,
      bySeverity: severityCounts,
      rules: this.rules.size,
      escalationTimers: this.escalationTimers.size,
    };
  }

  /**
   * Get system status
   */
  getStatus() {
    return {
      isRunning: this.isRunning,
      enabled: this.config.enabled,
      channels: Object.fromEntries(
        Object.entries(this.config.channels).map(([name, config]) => [
          name,
          { enabled: config.enabled }
        ])
      ),
      stats: this.getAlertStats(),
    };
  }
}

// Export singleton instance
const alertingSystem = new AlertingSystem();

export default alertingSystem;
export { AlertingSystem };</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ABTestingManager.html">ABTestingManager</a></li><li><a href="APILoader.html">APILoader</a></li><li><a href="AnthropicAdapter.html">AnthropicAdapter</a></li><li><a href="AuditLogger.html">AuditLogger</a></li><li><a href="AuthManager.html">AuthManager</a></li><li><a href="AuthMiddleware.html">AuthMiddleware</a></li><li><a href="AzureOpenAIAdapter.html">AzureOpenAIAdapter</a></li><li><a href="BPETokenizer.html">BPETokenizer</a></li><li><a href="BaseEngine.html">BaseEngine</a></li><li><a href="BaseLoader.html">BaseLoader</a></li><li><a href="BedrockAdapter.html">BedrockAdapter</a></li><li><a href="BinaryLoader.html">BinaryLoader</a></li><li><a href="BinaryModel.html">BinaryModel</a></li><li><a href="BitNetLoader.html">BitNetLoader</a></li><li><a href="CohereAdapter.html">CohereAdapter</a></li><li><a href="ConversionConfig.html">ConversionConfig</a></li><li><a href="ConversionResult.html">ConversionResult</a></li><li><a href="DeepSeekAdapter.html">DeepSeekAdapter</a></li><li><a href="EnterpriseAuthManager.html">EnterpriseAuthManager</a></li><li><a href="EnterpriseManager.html">EnterpriseManager</a></li><li><a href="EnterpriseRouter.html">EnterpriseRouter</a></li><li><a href="ErrorHandler.html">ErrorHandler</a></li><li><a href="FireworksAdapter.html">FireworksAdapter</a></li><li><a href="FormatConverter.html">FormatConverter</a></li><li><a href="GGUFLoader.html">GGUFLoader</a></li><li><a href="GGUFModel.html">GGUFModel</a></li><li><a href="GRPCClient.html">GRPCClient</a></li><li><a href="GroqAdapter.html">GroqAdapter</a></li><li><a href="LLMRouter.html">LLMRouter</a></li><li><a href="MistralAdapter.html">MistralAdapter</a></li><li><a href="MockLoader.html">MockLoader</a></li><li><a href="MockModel.html">MockModel</a></li><li><a href="ModelError.html">ModelError</a></li><li><a href="ModelInterface.html">ModelInterface</a></li><li><a href="ModelQuantizer.html">ModelQuantizer</a></li><li><a href="ModelRegistry.html">ModelRegistry</a></li><li><a href="ModelTemplates.html">ModelTemplates</a></li><li><a href="MultiTenancyManager.html">MultiTenancyManager</a></li><li><a href="NovitaAdapter.html">NovitaAdapter</a></li><li><a href="OpenAIAdapter.html">OpenAIAdapter</a></li><li><a href="OpenRouterAdapter.html">OpenRouterAdapter</a></li><li><a href="PerplexityAdapter.html">PerplexityAdapter</a></li><li><a href="Pipeline.html">Pipeline</a></li><li><a href="PyTorchLoader.html">PyTorchLoader</a></li><li><a href="PyTorchModel.html">PyTorchModel</a></li><li><a href="QuantizationConfig.html">QuantizationConfig</a></li><li><a href="QuantizationResult.html">QuantizationResult</a></li><li><a href="Router.html">Router</a></li><li><a href="SLAMonitor.html">SLAMonitor</a></li><li><a href="SentencePieceTokenizer.html">SentencePieceTokenizer</a></li><li><a href="SimpleLoader.html">SimpleLoader</a></li><li><a href="SimpleModel.html">SimpleModel</a></li><li><a href="TogetherAdapter.html">TogetherAdapter</a></li><li><a href="TokenizationResult.html">TokenizationResult</a></li><li><a href="TokenizerConfig.html">TokenizerConfig</a></li><li><a href="UniversalTokenizer.html">UniversalTokenizer</a></li><li><a href="ValidationConfig.html">ValidationConfig</a></li><li><a href="ValidationSuite.html">ValidationSuite</a></li><li><a href="ValidationSuiteResult.html">ValidationSuiteResult</a></li><li><a href="ValidationTestResult.html">ValidationTestResult</a></li><li><a href="VertexAIAdapter.html">VertexAIAdapter</a></li><li><a href="WordPieceTokenizer.html">WordPieceTokenizer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ADAPTER_REGISTRY">ADAPTER_REGISTRY</a></li><li><a href="global.html#API_KEY_PATTERNS">API_KEY_PATTERNS</a></li><li><a href="global.html#AUTH_TYPES">AUTH_TYPES</a></li><li><a href="global.html#AZURE_API_VERSIONS">AZURE_API_VERSIONS</a></li><li><a href="global.html#AZURE_OPENAI_MODELS">AZURE_OPENAI_MODELS</a></li><li><a href="global.html#Architectures">Architectures</a></li><li><a href="global.html#AuditEventTypes">AuditEventTypes</a></li><li><a href="global.html#AuthMethods">AuthMethods</a></li><li><a href="global.html#BEDROCK_MODELS">BEDROCK_MODELS</a></li><li><a href="global.html#BreachSeverity">BreachSeverity</a></li><li><a href="global.html#CLAUDE_MODELS">CLAUDE_MODELS</a></li><li><a href="global.html#COHERE_MODELS">COHERE_MODELS</a></li><li><a href="global.html#COMPLIANCE_FEATURES">COMPLIANCE_FEATURES</a></li><li><a href="global.html#Capabilities">Capabilities</a></li><li><a href="global.html#ComplianceFrameworks">ComplianceFrameworks</a></li><li><a href="global.html#DEEPSEEK_ENDPOINTS">DEEPSEEK_ENDPOINTS</a></li><li><a href="global.html#DEEPSEEK_MODELS">DEEPSEEK_MODELS</a></li><li><a href="global.html#EnterpriseFeatures">EnterpriseFeatures</a></li><li><a href="global.html#ExperimentStatus">ExperimentStatus</a></li><li><a href="global.html#FIREWORKS_MODELS">FIREWORKS_MODELS</a></li><li><a href="global.html#GROQ_MODELS">GROQ_MODELS</a></li><li><a href="global.html#INPUT_TYPES">INPUT_TYPES</a></li><li><a href="global.html#IsolationLevels">IsolationLevels</a></li><li><a href="global.html#MISTRAL_MODELS">MISTRAL_MODELS</a></li><li><a href="global.html#MODEL_CATEGORIES">MODEL_CATEGORIES</a></li><li><a href="global.html#ModelFormat">ModelFormat</a></li><li><a href="global.html#ModelFormats">ModelFormats</a></li><li><a href="global.html#NOVITA_ENDPOINTS">NOVITA_ENDPOINTS</a></li><li><a href="global.html#NOVITA_MODELS">NOVITA_MODELS</a></li><li><a href="global.html#OPENAI_MODELS">OPENAI_MODELS</a></li><li><a href="global.html#PERPLEXITY_MODELS">PERPLEXITY_MODELS</a></li><li><a href="global.html#POPULAR_MODELS">POPULAR_MODELS</a></li><li><a href="global.html#PROVIDER_AUTH_CONFIG">PROVIDER_AUTH_CONFIG</a></li><li><a href="global.html#PROVIDER_CATEGORIES">PROVIDER_CATEGORIES</a></li><li><a href="global.html#PROVIDER_CONFIGS">PROVIDER_CONFIGS</a></li><li><a href="global.html#PROVIDER_FEATURES">PROVIDER_FEATURES</a></li><li><a href="global.html#Permissions">Permissions</a></li><li><a href="global.html#QuantizationMethod">QuantizationMethod</a></li><li><a href="global.html#QuantizationPrecision">QuantizationPrecision</a></li><li><a href="global.html#QuotaTypes">QuotaTypes</a></li><li><a href="global.html#RiskLevels">RiskLevels</a></li><li><a href="global.html#RoutingStrategies">RoutingStrategies</a></li><li><a href="global.html#SAFETY_LEVELS">SAFETY_LEVELS</a></li><li><a href="global.html#SLAMetricTypes">SLAMetricTypes</a></li><li><a href="global.html#SLAStatus">SLAStatus</a></li><li><a href="global.html#SessionTypes">SessionTypes</a></li><li><a href="global.html#SplittingAlgorithms">SplittingAlgorithms</a></li><li><a href="global.html#StatisticalTests">StatisticalTests</a></li><li><a href="global.html#TOGETHER_MODELS">TOGETHER_MODELS</a></li><li><a href="global.html#TimeWindows">TimeWindows</a></li><li><a href="global.html#TokenizerType">TokenizerType</a></li><li><a href="global.html#UserRoles">UserRoles</a></li><li><a href="global.html#VERTEX_AI_MODELS">VERTEX_AI_MODELS</a></li><li><a href="global.html#VERTEX_REGIONS">VERTEX_REGIONS</a></li><li><a href="global.html#ValidationSeverity">ValidationSeverity</a></li><li><a href="global.html#ValidationTestType">ValidationTestType</a></li><li><a href="global.html#adjustTimeouts">adjustTimeouts</a></li><li><a href="global.html#attemptRecovery">attemptRecovery</a></li><li><a href="global.html#checkConnectivity">checkConnectivity</a></li><li><a href="global.html#clearCache">clearCache</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#createAdapter">createAdapter</a></li><li><a href="global.html#createEnterpriseExpressRoutes">createEnterpriseExpressRoutes</a></li><li><a href="global.html#createEnterpriseRouter">createEnterpriseRouter</a></li><li><a href="global.html#createEnterpriseWebSocketHandlers">createEnterpriseWebSocketHandlers</a></li><li><a href="global.html#createMissingResources">createMissingResources</a></li><li><a href="global.html#defaultEnterpriseConfig">defaultEnterpriseConfig</a></li><li><a href="global.html#emergencyShutdown">emergencyShutdown</a></li><li><a href="global.html#enterpriseVersion">enterpriseVersion</a></li><li><a href="global.html#errorMonitoringMiddleware">errorMonitoringMiddleware</a></li><li><a href="global.html#escalateError">escalateError</a></li><li><a href="global.html#executeRecovery">executeRecovery</a></li><li><a href="global.html#getAdapter">getAdapter</a></li><li><a href="global.html#getEnabledFeatures">getEnabledFeatures</a></li><li><a href="global.html#getMonitoringStatus">getMonitoringStatus</a></li><li><a href="global.html#getProviderAuthType">getProviderAuthType</a></li><li><a href="global.html#getProviderInfo">getProviderInfo</a></li><li><a href="global.html#getProvidersByCategory">getProvidersByCategory</a></li><li><a href="global.html#getProvidersByFeature">getProvidersByFeature</a></li><li><a href="global.html#getStats">getStats</a></li><li><a href="global.html#getSupportedProviders">getSupportedProviders</a></li><li><a href="global.html#gracefulShutdown">gracefulShutdown</a></li><li><a href="global.html#handleCriticalError">handleCriticalError</a></li><li><a href="global.html#handleMemoryLeak">handleMemoryLeak</a></li><li><a href="global.html#httpMonitoringMiddleware">httpMonitoringMiddleware</a></li><li><a href="global.html#isFeatureEnabled">isFeatureEnabled</a></li><li><a href="global.html#isProviderSupported">isProviderSupported</a></li><li><a href="global.html#logError">logError</a></li><li><a href="global.html#performHealthCheck">performHealthCheck</a></li><li><a href="global.html#recordCustomMetric">recordCustomMetric</a></li><li><a href="global.html#registerAlertRule">registerAlertRule</a></li><li><a href="global.html#registerDependency">registerDependency</a></li><li><a href="global.html#registerHealthCheck">registerHealthCheck</a></li><li><a href="global.html#reinstallDependencies">reinstallDependencies</a></li><li><a href="global.html#reload">reload</a></li><li><a href="global.html#restartProcess">restartProcess</a></li><li><a href="global.html#retryConnection">retryConnection</a></li><li><a href="global.html#selectRecoveryStrategy">selectRecoveryStrategy</a></li><li><a href="global.html#setupHandlers">setupHandlers</a></li><li><a href="global.html#setupMonitoring">setupMonitoring</a></li><li><a href="global.html#softRestart">softRestart</a></li><li><a href="global.html#startHealthMonitoring">startHealthMonitoring</a></li><li><a href="global.html#startPerformanceProfile">startPerformanceProfile</a></li><li><a href="global.html#validateEnterpriseConfig">validateEnterpriseConfig</a></li><li><a href="global.html#withCacheMonitoring">withCacheMonitoring</a></li><li><a href="global.html#withDatabaseMonitoring">withDatabaseMonitoring</a></li><li><a href="global.html#withModelMonitoring">withModelMonitoring</a></li><li><a href="global.html#withQueueMonitoring">withQueueMonitoring</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Aug 20 2025 19:41:21 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
