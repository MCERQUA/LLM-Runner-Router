<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: runtime/CacheManager.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: runtime/CacheManager.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Cache Manager
 * Multi-tier caching system for models and inference results
 * Implements L1 (memory), L2 (disk), and L3 (distributed) caching
 */

import { Logger } from '../utils/Logger.js';
import { LRUCache } from 'lru-cache';
import crypto from 'crypto';
import fs from 'fs/promises';
import path from 'path';
import { performance } from 'perf_hooks';

class CacheManager {
  constructor(config = {}) {
    this.logger = new Logger('CacheManager');
    this.config = {
      // L1 Cache (Memory)
      l1Size: config.l1Size || 100, // Number of items
      l1MaxSize: config.l1MaxSize || 500 * 1024 * 1024, // 500MB
      l1TTL: config.l1TTL || 1000 * 60 * 5, // 5 minutes
      
      // L2 Cache (Disk)
      l2Enabled: config.l2Enabled !== false,
      l2Path: config.l2Path || './cache/l2',
      l2MaxSize: config.l2MaxSize || 5 * 1024 * 1024 * 1024, // 5GB
      l2TTL: config.l2TTL || 1000 * 60 * 60, // 1 hour
      
      // L3 Cache (Distributed - Redis/etc)
      l3Enabled: config.l3Enabled || false,
      l3Config: config.l3Config || {},
      
      // General settings
      compressionEnabled: config.compressionEnabled !== false,
      encryptionEnabled: config.encryptionEnabled || false,
      encryptionKey: config.encryptionKey || null,
      
      // Cache warming
      warmupEnabled: config.warmupEnabled || false,
      warmupPatterns: config.warmupPatterns || []
    };
    
    // Initialize caches
    this.l1Cache = null;
    this.l3Client = null;
    
    // Statistics
    this.stats = {
      l1Hits: 0,
      l1Misses: 0,
      l2Hits: 0,
      l2Misses: 0,
      l3Hits: 0,
      l3Misses: 0,
      totalHits: 0,
      totalMisses: 0,
      bytesServed: 0,
      bytesSaved: 0
    };
    
    // Cache metadata
    this.metadata = new Map();
  }

  /**
   * Initialize cache manager
   */
  async initialize() {
    this.logger.info('Initializing Cache Manager');
    
    // Initialize L1 cache (memory)
    this.initializeL1Cache();
    
    // Initialize L2 cache (disk)
    if (this.config.l2Enabled) {
      await this.initializeL2Cache();
    }
    
    // Initialize L3 cache (distributed)
    if (this.config.l3Enabled) {
      await this.initializeL3Cache();
    }
    
    // Warm up cache if enabled
    if (this.config.warmupEnabled) {
      await this.warmupCache();
    }
    
    return true;
  }

  /**
   * Initialize L1 (memory) cache
   */
  initializeL1Cache() {
    this.l1Cache = new LRUCache({
      max: this.config.l1Size,
      maxSize: this.config.l1MaxSize,
      ttl: this.config.l1TTL,
      sizeCalculation: (value) => {
        if (typeof value === 'string') return value.length;
        if (Buffer.isBuffer(value)) return value.length;
        if (value instanceof ArrayBuffer) return value.byteLength;
        return JSON.stringify(value).length;
      },
      dispose: (value, key) => {
        this.logger.debug(`L1 cache evicting: ${key}`);
      }
    });
    
    this.logger.info(`L1 cache initialized with ${this.config.l1Size} items max`);
  }

  /**
   * Initialize L2 (disk) cache
   */
  async initializeL2Cache() {
    try {
      await fs.mkdir(this.config.l2Path, { recursive: true });
      
      // Clean up old cache files
      await this.cleanupL2Cache();
      
      this.logger.info(`L2 cache initialized at ${this.config.l2Path}`);
    } catch (error) {
      this.logger.error(`Failed to initialize L2 cache: ${error.message}`);
      this.config.l2Enabled = false;
    }
  }

  /**
   * Initialize L3 (distributed) cache
   */
  async initializeL3Cache() {
    try {
      // This would connect to Redis, Memcached, etc.
      // For now, it's a placeholder
      this.logger.info('L3 cache initialization placeholder');
      this.config.l3Enabled = false; // Disable for now
    } catch (error) {
      this.logger.error(`Failed to initialize L3 cache: ${error.message}`);
      this.config.l3Enabled = false;
    }
  }

  /**
   * Generate cache key
   */
  generateKey(identifier, params = {}) {
    const keyData = {
      id: identifier,
      ...params
    };
    
    const keyString = JSON.stringify(keyData, Object.keys(keyData).sort());
    return crypto.createHash('sha256').update(keyString).digest('hex');
  }

  /**
   * Get from cache (checks all tiers)
   */
  async get(key, options = {}) {
    const startTime = performance.now();
    
    // Check L1 cache
    let value = this.l1Cache.get(key);
    if (value !== undefined) {
      this.stats.l1Hits++;
      this.stats.totalHits++;
      this.updateAccessMetadata(key, 'l1');
      this.logger.debug(`L1 cache hit for ${key}`);
      return this.deserializeValue(value);
    }
    this.stats.l1Misses++;
    
    // Check L2 cache
    if (this.config.l2Enabled) {
      value = await this.getFromL2(key);
      if (value !== undefined) {
        this.stats.l2Hits++;
        this.stats.totalHits++;
        
        // Promote to L1
        if (options.promoteToL1 !== false) {
          this.l1Cache.set(key, value);
        }
        
        this.updateAccessMetadata(key, 'l2');
        this.logger.debug(`L2 cache hit for ${key}`);
        return this.deserializeValue(value);
      }
      this.stats.l2Misses++;
    }
    
    // Check L3 cache
    if (this.config.l3Enabled) {
      value = await this.getFromL3(key);
      if (value !== undefined) {
        this.stats.l3Hits++;
        this.stats.totalHits++;
        
        // Promote to L1 and L2
        if (options.promoteToL1 !== false) {
          this.l1Cache.set(key, value);
        }
        if (options.promoteToL2 !== false &amp;&amp; this.config.l2Enabled) {
          await this.setInL2(key, value);
        }
        
        this.updateAccessMetadata(key, 'l3');
        this.logger.debug(`L3 cache hit for ${key}`);
        return this.deserializeValue(value);
      }
      this.stats.l3Misses++;
    }
    
    this.stats.totalMisses++;
    const duration = performance.now() - startTime;
    this.logger.debug(`Cache miss for ${key} (${duration.toFixed(2)}ms)`);
    
    return undefined;
  }

  /**
   * Set in cache (writes to appropriate tiers)
   */
  async set(key, value, options = {}) {
    const serialized = this.serializeValue(value);
    const size = this.calculateSize(serialized);
    
    // Update statistics
    this.stats.bytesSaved += size;
    
    // Determine which tiers to write to
    const tiers = options.tiers || ['l1', 'l2'];
    
    // Write to L1
    if (tiers.includes('l1')) {
      this.l1Cache.set(key, serialized, {
        ttl: options.ttl || this.config.l1TTL
      });
    }
    
    // Write to L2
    if (tiers.includes('l2') &amp;&amp; this.config.l2Enabled) {
      await this.setInL2(key, serialized, options);
    }
    
    // Write to L3
    if (tiers.includes('l3') &amp;&amp; this.config.l3Enabled) {
      await this.setInL3(key, serialized, options);
    }
    
    // Update metadata
    this.metadata.set(key, {
      size,
      created: Date.now(),
      accessed: Date.now(),
      accessCount: 0,
      tiers
    });
    
    return true;
  }

  /**
   * Get from L2 (disk) cache
   */
  async getFromL2(key) {
    try {
      const filePath = this.getL2FilePath(key);
      const data = await fs.readFile(filePath);
      
      // Check if expired
      const stats = await fs.stat(filePath);
      const age = Date.now() - stats.mtimeMs;
      
      if (age > this.config.l2TTL) {
        await fs.unlink(filePath);
        return undefined;
      }
      
      // Decompress if needed
      let value = data;
      if (this.config.compressionEnabled) {
        value = await this.decompress(value);
      }
      
      // Decrypt if needed
      if (this.config.encryptionEnabled) {
        value = await this.decrypt(value);
      }
      
      this.stats.bytesServed += value.length;
      return value;
    } catch (error) {
      if (error.code !== 'ENOENT') {
        this.logger.error(`L2 cache read error: ${error.message}`);
      }
      return undefined;
    }
  }

  /**
   * Set in L2 (disk) cache
   */
  async setInL2(key, value, options = {}) {
    try {
      const filePath = this.getL2FilePath(key);
      await fs.mkdir(path.dirname(filePath), { recursive: true });
      
      let data = value;
      
      // Encrypt if enabled
      if (this.config.encryptionEnabled) {
        data = await this.encrypt(data);
      }
      
      // Compress if enabled
      if (this.config.compressionEnabled) {
        data = await this.compress(data);
      }
      
      await fs.writeFile(filePath, data);
      
      // Set TTL via file modification time
      const ttl = options.ttl || this.config.l2TTL;
      const expireTime = new Date(Date.now() + ttl);
      await fs.utimes(filePath, expireTime, expireTime);
      
      return true;
    } catch (error) {
      this.logger.error(`L2 cache write error: ${error.message}`);
      return false;
    }
  }

  /**
   * Get from L3 (distributed) cache
   */
  async getFromL3(key) {
    // Placeholder for distributed cache implementation
    return undefined;
  }

  /**
   * Set in L3 (distributed) cache
   */
  async setInL3(key, value, options = {}) {
    // Placeholder for distributed cache implementation
    return false;
  }

  /**
   * Get L2 cache file path
   */
  getL2FilePath(key) {
    // Use first 2 chars of key for directory sharding
    const shard = key.substring(0, 2);
    return path.join(this.config.l2Path, shard, `${key}.cache`);
  }

  /**
   * Delete from cache
   */
  async delete(key) {
    // Delete from all tiers
    this.l1Cache.delete(key);
    
    if (this.config.l2Enabled) {
      try {
        const filePath = this.getL2FilePath(key);
        await fs.unlink(filePath);
      } catch (error) {
        // Ignore if file doesn't exist
      }
    }
    
    if (this.config.l3Enabled) {
      // Delete from L3
    }
    
    this.metadata.delete(key);
    
    return true;
  }

  /**
   * Clear all caches
   */
  async clear() {
    // Clear L1
    this.l1Cache.clear();
    
    // Clear L2
    if (this.config.l2Enabled) {
      await this.clearL2Cache();
    }
    
    // Clear L3
    if (this.config.l3Enabled) {
      // Clear distributed cache
    }
    
    // Clear metadata
    this.metadata.clear();
    
    // Reset statistics
    this.resetStatistics();
    
    this.logger.info('All caches cleared');
  }

  /**
   * Clear L2 cache
   */
  async clearL2Cache() {
    try {
      const files = await fs.readdir(this.config.l2Path, { recursive: true });
      for (const file of files) {
        if (file.endsWith('.cache')) {
          await fs.unlink(path.join(this.config.l2Path, file));
        }
      }
    } catch (error) {
      this.logger.error(`Failed to clear L2 cache: ${error.message}`);
    }
  }

  /**
   * Clean up expired L2 cache entries
   */
  async cleanupL2Cache() {
    try {
      const now = Date.now();
      const files = await fs.readdir(this.config.l2Path, { recursive: true });
      
      for (const file of files) {
        if (file.endsWith('.cache')) {
          const filePath = path.join(this.config.l2Path, file);
          const stats = await fs.stat(filePath);
          const age = now - stats.mtimeMs;
          
          if (age > this.config.l2TTL) {
            await fs.unlink(filePath);
            this.logger.debug(`Cleaned up expired L2 cache file: ${file}`);
          }
        }
      }
    } catch (error) {
      this.logger.error(`L2 cache cleanup error: ${error.message}`);
    }
  }

  /**
   * Warm up cache with predefined patterns
   */
  async warmupCache() {
    this.logger.info('Warming up cache');
    
    for (const pattern of this.config.warmupPatterns) {
      try {
        // Load pattern data
        const data = await this.loadWarmupData(pattern);
        if (data) {
          const key = this.generateKey(pattern.id, pattern.params);
          await this.set(key, data, { tiers: ['l1', 'l2'] });
        }
      } catch (error) {
        this.logger.error(`Failed to warm up cache for ${pattern.id}: ${error.message}`);
      }
    }
  }

  /**
   * Load warmup data
   */
  async loadWarmupData(pattern) {
    // This would load actual data based on pattern
    // For now, it's a placeholder
    return null;
  }

  /**
   * Compress data
   */
  async compress(data) {
    // In real implementation, would use zlib or similar
    return data;
  }

  /**
   * Decompress data
   */
  async decompress(data) {
    // In real implementation, would use zlib or similar
    return data;
  }

  /**
   * Encrypt data
   */
  async encrypt(data) {
    if (!this.config.encryptionKey) return data;
    
    // In real implementation, would use crypto module
    return data;
  }

  /**
   * Decrypt data
   */
  async decrypt(data) {
    if (!this.config.encryptionKey) return data;
    
    // In real implementation, would use crypto module
    return data;
  }

  /**
   * Serialize value for caching
   */
  serializeValue(value) {
    if (Buffer.isBuffer(value)) return value;
    if (typeof value === 'string') return Buffer.from(value);
    return Buffer.from(JSON.stringify(value));
  }

  /**
   * Deserialize cached value
   */
  deserializeValue(value) {
    if (!Buffer.isBuffer(value)) return value;
    
    try {
      // Try to parse as JSON
      const str = value.toString();
      return JSON.parse(str);
    } catch {
      // Return as string if not JSON
      return value.toString();
    }
  }

  /**
   * Calculate size of value
   */
  calculateSize(value) {
    if (Buffer.isBuffer(value)) return value.length;
    if (typeof value === 'string') return value.length;
    return JSON.stringify(value).length;
  }

  /**
   * Update access metadata
   */
  updateAccessMetadata(key, tier) {
    const meta = this.metadata.get(key);
    if (meta) {
      meta.accessed = Date.now();
      meta.accessCount++;
      meta.lastTier = tier;
    }
  }

  /**
   * Get cache statistics
   */
  getStatistics() {
    const l1Stats = this.l1Cache ? {
      size: this.l1Cache.size,
      calculatedSize: this.l1Cache.calculatedSize,
      hitRate: this.stats.l1Hits / (this.stats.l1Hits + this.stats.l1Misses) || 0
    } : null;
    
    return {
      ...this.stats,
      l1: l1Stats,
      overallHitRate: this.stats.totalHits / (this.stats.totalHits + this.stats.totalMisses) || 0,
      bytesServedMB: (this.stats.bytesServed / 1024 / 1024).toFixed(2),
      bytesSavedMB: (this.stats.bytesSaved / 1024 / 1024).toFixed(2)
    };
  }

  /**
   * Reset statistics
   */
  resetStatistics() {
    this.stats = {
      l1Hits: 0,
      l1Misses: 0,
      l2Hits: 0,
      l2Misses: 0,
      l3Hits: 0,
      l3Misses: 0,
      totalHits: 0,
      totalMisses: 0,
      bytesServed: 0,
      bytesSaved: 0
    };
  }

  /**
   * Clean up resources
   */
  async cleanup() {
    this.logger.info('Cleaning up Cache Manager');
    
    // Clear all caches
    await this.clear();
    
    // Close connections
    if (this.l3Client) {
      // Close distributed cache connection
    }
  }
}
export default CacheManager;
export { CacheManager };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ABTestingManager.html">ABTestingManager</a></li><li><a href="APILoader.html">APILoader</a></li><li><a href="AnthropicAdapter.html">AnthropicAdapter</a></li><li><a href="AuditLogger.html">AuditLogger</a></li><li><a href="AuthManager.html">AuthManager</a></li><li><a href="AuthMiddleware.html">AuthMiddleware</a></li><li><a href="AzureOpenAIAdapter.html">AzureOpenAIAdapter</a></li><li><a href="BPETokenizer.html">BPETokenizer</a></li><li><a href="BaseEngine.html">BaseEngine</a></li><li><a href="BaseLoader.html">BaseLoader</a></li><li><a href="BedrockAdapter.html">BedrockAdapter</a></li><li><a href="BinaryLoader.html">BinaryLoader</a></li><li><a href="BinaryModel.html">BinaryModel</a></li><li><a href="BitNetLoader.html">BitNetLoader</a></li><li><a href="CohereAdapter.html">CohereAdapter</a></li><li><a href="ConversionConfig.html">ConversionConfig</a></li><li><a href="ConversionResult.html">ConversionResult</a></li><li><a href="DeepSeekAdapter.html">DeepSeekAdapter</a></li><li><a href="EnterpriseAuthManager.html">EnterpriseAuthManager</a></li><li><a href="EnterpriseManager.html">EnterpriseManager</a></li><li><a href="EnterpriseRouter.html">EnterpriseRouter</a></li><li><a href="ErrorHandler.html">ErrorHandler</a></li><li><a href="FireworksAdapter.html">FireworksAdapter</a></li><li><a href="FormatConverter.html">FormatConverter</a></li><li><a href="GGUFLoader.html">GGUFLoader</a></li><li><a href="GGUFModel.html">GGUFModel</a></li><li><a href="GRPCClient.html">GRPCClient</a></li><li><a href="GroqAdapter.html">GroqAdapter</a></li><li><a href="LLMRouter.html">LLMRouter</a></li><li><a href="MistralAdapter.html">MistralAdapter</a></li><li><a href="MockLoader.html">MockLoader</a></li><li><a href="MockModel.html">MockModel</a></li><li><a href="ModelError.html">ModelError</a></li><li><a href="ModelInterface.html">ModelInterface</a></li><li><a href="ModelQuantizer.html">ModelQuantizer</a></li><li><a href="ModelRegistry.html">ModelRegistry</a></li><li><a href="ModelTemplates.html">ModelTemplates</a></li><li><a href="MultiTenancyManager.html">MultiTenancyManager</a></li><li><a href="NovitaAdapter.html">NovitaAdapter</a></li><li><a href="OpenAIAdapter.html">OpenAIAdapter</a></li><li><a href="OpenRouterAdapter.html">OpenRouterAdapter</a></li><li><a href="PerplexityAdapter.html">PerplexityAdapter</a></li><li><a href="Pipeline.html">Pipeline</a></li><li><a href="PyTorchLoader.html">PyTorchLoader</a></li><li><a href="PyTorchModel.html">PyTorchModel</a></li><li><a href="QuantizationConfig.html">QuantizationConfig</a></li><li><a href="QuantizationResult.html">QuantizationResult</a></li><li><a href="Router.html">Router</a></li><li><a href="SLAMonitor.html">SLAMonitor</a></li><li><a href="SentencePieceTokenizer.html">SentencePieceTokenizer</a></li><li><a href="SimpleLoader.html">SimpleLoader</a></li><li><a href="SimpleModel.html">SimpleModel</a></li><li><a href="TogetherAdapter.html">TogetherAdapter</a></li><li><a href="TokenizationResult.html">TokenizationResult</a></li><li><a href="TokenizerConfig.html">TokenizerConfig</a></li><li><a href="UniversalTokenizer.html">UniversalTokenizer</a></li><li><a href="ValidationConfig.html">ValidationConfig</a></li><li><a href="ValidationSuite.html">ValidationSuite</a></li><li><a href="ValidationSuiteResult.html">ValidationSuiteResult</a></li><li><a href="ValidationTestResult.html">ValidationTestResult</a></li><li><a href="VertexAIAdapter.html">VertexAIAdapter</a></li><li><a href="WordPieceTokenizer.html">WordPieceTokenizer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ADAPTER_REGISTRY">ADAPTER_REGISTRY</a></li><li><a href="global.html#API_KEY_PATTERNS">API_KEY_PATTERNS</a></li><li><a href="global.html#AUTH_TYPES">AUTH_TYPES</a></li><li><a href="global.html#AZURE_API_VERSIONS">AZURE_API_VERSIONS</a></li><li><a href="global.html#AZURE_OPENAI_MODELS">AZURE_OPENAI_MODELS</a></li><li><a href="global.html#Architectures">Architectures</a></li><li><a href="global.html#AuditEventTypes">AuditEventTypes</a></li><li><a href="global.html#AuthMethods">AuthMethods</a></li><li><a href="global.html#BEDROCK_MODELS">BEDROCK_MODELS</a></li><li><a href="global.html#BreachSeverity">BreachSeverity</a></li><li><a href="global.html#CLAUDE_MODELS">CLAUDE_MODELS</a></li><li><a href="global.html#COHERE_MODELS">COHERE_MODELS</a></li><li><a href="global.html#COMPLIANCE_FEATURES">COMPLIANCE_FEATURES</a></li><li><a href="global.html#Capabilities">Capabilities</a></li><li><a href="global.html#ComplianceFrameworks">ComplianceFrameworks</a></li><li><a href="global.html#DEEPSEEK_ENDPOINTS">DEEPSEEK_ENDPOINTS</a></li><li><a href="global.html#DEEPSEEK_MODELS">DEEPSEEK_MODELS</a></li><li><a href="global.html#EnterpriseFeatures">EnterpriseFeatures</a></li><li><a href="global.html#ExperimentStatus">ExperimentStatus</a></li><li><a href="global.html#FIREWORKS_MODELS">FIREWORKS_MODELS</a></li><li><a href="global.html#GROQ_MODELS">GROQ_MODELS</a></li><li><a href="global.html#INPUT_TYPES">INPUT_TYPES</a></li><li><a href="global.html#IsolationLevels">IsolationLevels</a></li><li><a href="global.html#MISTRAL_MODELS">MISTRAL_MODELS</a></li><li><a href="global.html#MODEL_CATEGORIES">MODEL_CATEGORIES</a></li><li><a href="global.html#ModelFormat">ModelFormat</a></li><li><a href="global.html#ModelFormats">ModelFormats</a></li><li><a href="global.html#NOVITA_ENDPOINTS">NOVITA_ENDPOINTS</a></li><li><a href="global.html#NOVITA_MODELS">NOVITA_MODELS</a></li><li><a href="global.html#OPENAI_MODELS">OPENAI_MODELS</a></li><li><a href="global.html#PERPLEXITY_MODELS">PERPLEXITY_MODELS</a></li><li><a href="global.html#POPULAR_MODELS">POPULAR_MODELS</a></li><li><a href="global.html#PROVIDER_AUTH_CONFIG">PROVIDER_AUTH_CONFIG</a></li><li><a href="global.html#PROVIDER_CATEGORIES">PROVIDER_CATEGORIES</a></li><li><a href="global.html#PROVIDER_CONFIGS">PROVIDER_CONFIGS</a></li><li><a href="global.html#PROVIDER_FEATURES">PROVIDER_FEATURES</a></li><li><a href="global.html#Permissions">Permissions</a></li><li><a href="global.html#QuantizationMethod">QuantizationMethod</a></li><li><a href="global.html#QuantizationPrecision">QuantizationPrecision</a></li><li><a href="global.html#QuotaTypes">QuotaTypes</a></li><li><a href="global.html#RiskLevels">RiskLevels</a></li><li><a href="global.html#RoutingStrategies">RoutingStrategies</a></li><li><a href="global.html#SAFETY_LEVELS">SAFETY_LEVELS</a></li><li><a href="global.html#SLAMetricTypes">SLAMetricTypes</a></li><li><a href="global.html#SLAStatus">SLAStatus</a></li><li><a href="global.html#SessionTypes">SessionTypes</a></li><li><a href="global.html#SplittingAlgorithms">SplittingAlgorithms</a></li><li><a href="global.html#StatisticalTests">StatisticalTests</a></li><li><a href="global.html#TOGETHER_MODELS">TOGETHER_MODELS</a></li><li><a href="global.html#TimeWindows">TimeWindows</a></li><li><a href="global.html#TokenizerType">TokenizerType</a></li><li><a href="global.html#UserRoles">UserRoles</a></li><li><a href="global.html#VERTEX_AI_MODELS">VERTEX_AI_MODELS</a></li><li><a href="global.html#VERTEX_REGIONS">VERTEX_REGIONS</a></li><li><a href="global.html#ValidationSeverity">ValidationSeverity</a></li><li><a href="global.html#ValidationTestType">ValidationTestType</a></li><li><a href="global.html#adjustTimeouts">adjustTimeouts</a></li><li><a href="global.html#attemptRecovery">attemptRecovery</a></li><li><a href="global.html#checkConnectivity">checkConnectivity</a></li><li><a href="global.html#clearCache">clearCache</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#createAdapter">createAdapter</a></li><li><a href="global.html#createEnterpriseExpressRoutes">createEnterpriseExpressRoutes</a></li><li><a href="global.html#createEnterpriseRouter">createEnterpriseRouter</a></li><li><a href="global.html#createEnterpriseWebSocketHandlers">createEnterpriseWebSocketHandlers</a></li><li><a href="global.html#createMissingResources">createMissingResources</a></li><li><a href="global.html#defaultEnterpriseConfig">defaultEnterpriseConfig</a></li><li><a href="global.html#emergencyShutdown">emergencyShutdown</a></li><li><a href="global.html#enterpriseVersion">enterpriseVersion</a></li><li><a href="global.html#errorMonitoringMiddleware">errorMonitoringMiddleware</a></li><li><a href="global.html#escalateError">escalateError</a></li><li><a href="global.html#executeRecovery">executeRecovery</a></li><li><a href="global.html#getAdapter">getAdapter</a></li><li><a href="global.html#getEnabledFeatures">getEnabledFeatures</a></li><li><a href="global.html#getMonitoringStatus">getMonitoringStatus</a></li><li><a href="global.html#getProviderAuthType">getProviderAuthType</a></li><li><a href="global.html#getProviderInfo">getProviderInfo</a></li><li><a href="global.html#getProvidersByCategory">getProvidersByCategory</a></li><li><a href="global.html#getProvidersByFeature">getProvidersByFeature</a></li><li><a href="global.html#getStats">getStats</a></li><li><a href="global.html#getSupportedProviders">getSupportedProviders</a></li><li><a href="global.html#gracefulShutdown">gracefulShutdown</a></li><li><a href="global.html#handleCriticalError">handleCriticalError</a></li><li><a href="global.html#handleMemoryLeak">handleMemoryLeak</a></li><li><a href="global.html#httpMonitoringMiddleware">httpMonitoringMiddleware</a></li><li><a href="global.html#isFeatureEnabled">isFeatureEnabled</a></li><li><a href="global.html#isProviderSupported">isProviderSupported</a></li><li><a href="global.html#logError">logError</a></li><li><a href="global.html#performHealthCheck">performHealthCheck</a></li><li><a href="global.html#recordCustomMetric">recordCustomMetric</a></li><li><a href="global.html#registerAlertRule">registerAlertRule</a></li><li><a href="global.html#registerDependency">registerDependency</a></li><li><a href="global.html#registerHealthCheck">registerHealthCheck</a></li><li><a href="global.html#reinstallDependencies">reinstallDependencies</a></li><li><a href="global.html#reload">reload</a></li><li><a href="global.html#restartProcess">restartProcess</a></li><li><a href="global.html#retryConnection">retryConnection</a></li><li><a href="global.html#selectRecoveryStrategy">selectRecoveryStrategy</a></li><li><a href="global.html#setupHandlers">setupHandlers</a></li><li><a href="global.html#setupMonitoring">setupMonitoring</a></li><li><a href="global.html#softRestart">softRestart</a></li><li><a href="global.html#startHealthMonitoring">startHealthMonitoring</a></li><li><a href="global.html#startPerformanceProfile">startPerformanceProfile</a></li><li><a href="global.html#validateEnterpriseConfig">validateEnterpriseConfig</a></li><li><a href="global.html#withCacheMonitoring">withCacheMonitoring</a></li><li><a href="global.html#withDatabaseMonitoring">withDatabaseMonitoring</a></li><li><a href="global.html#withModelMonitoring">withModelMonitoring</a></li><li><a href="global.html#withQueueMonitoring">withQueueMonitoring</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Aug 20 2025 19:41:21 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
