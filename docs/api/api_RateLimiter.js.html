<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: api/RateLimiter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: api/RateLimiter.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Advanced Rate Limiting System for LLM Runner Router
 * Supports multiple strategies, Redis clustering, and intelligent throttling
 */

import RateLimiterFlexiblePkg from 'rate-limiter-flexible';
const { RateLimiterMemory, RateLimiterRedis } = RateLimiterFlexiblePkg;
import Redis from 'ioredis';
import { EventEmitter } from 'events';

export class RateLimitManager extends EventEmitter {
  constructor(options = {}) {
    super();
    this.options = {
      // Redis configuration
      redis: {
        host: options.redis?.host || process.env.REDIS_HOST || 'localhost',
        port: options.redis?.port || process.env.REDIS_PORT || 6379,
        password: options.redis?.password || process.env.REDIS_PASSWORD,
        db: options.redis?.db || 0,
        keyPrefix: options.redis?.keyPrefix || 'rl:',
        ...options.redis
      },
      // Default rate limiting rules
      defaultLimits: {
        // Per-user limits
        user: {
          requests: 1000,
          window: 3600, // 1 hour
          burst: 50 // Allow bursts up to 50 requests
        },
        // Per-IP limits
        ip: {
          requests: 500,
          window: 3600, // 1 hour
          burst: 25
        },
        // Per-API-key limits
        apiKey: {
          requests: 5000,
          window: 3600, // 1 hour
          burst: 100
        },
        // Global limits
        global: {
          requests: 50000,
          window: 3600, // 1 hour
          burst: 1000
        }
      },
      // Rate limiting strategies
      strategies: {
        // Fixed window
        fixedWindow: {
          enabled: true,
          windowSizeMs: 60000, // 1 minute
          maxRequests: 100
        },
        // Sliding window
        slidingWindow: {
          enabled: true,
          windowSizeMs: 60000, // 1 minute
          maxRequests: 100,
          precision: 1000 // 1 second precision
        },
        // Token bucket
        tokenBucket: {
          enabled: true,
          capacity: 100,
          refillRate: 10, // tokens per second
          refillAmount: 1
        },
        // Leaky bucket
        leakyBucket: {
          enabled: true,
          capacity: 100,
          leakRate: 10 // requests per second
        },
        // Adaptive rate limiting
        adaptive: {
          enabled: true,
          baseLimit: 100,
          maxLimit: 1000,
          minLimit: 10,
          adjustmentFactor: 0.1,
          errorThreshold: 0.05,
          successThreshold: 0.95
        }
      },
      // Tier-based limits
      tiers: {
        free: {
          requestsPerHour: 100,
          requestsPerMinute: 10,
          concurrentRequests: 2,
          costMultiplier: 1
        },
        basic: {
          requestsPerHour: 1000,
          requestsPerMinute: 50,
          concurrentRequests: 5,
          costMultiplier: 1
        },
        premium: {
          requestsPerHour: 10000,
          requestsPerMinute: 200,
          concurrentRequests: 20,
          costMultiplier: 1
        },
        enterprise: {
          requestsPerHour: 100000,
          requestsPerMinute: 2000,
          concurrentRequests: 100,
          costMultiplier: 1
        }
      },
      // Intelligent features
      useRedis: options.useRedis !== false,
      enableAdaptiveRateLimiting: options.enableAdaptiveRateLimiting !== false,
      enableCostBasedLimiting: options.enableCostBasedLimiting !== false,
      enableGeoBasedLimiting: options.enableGeoBasedLimiting !== false,
      enableAnomalyDetection: options.enableAnomalyDetection !== false,
      ...options
    };

    this.redis = null;
    this.limiters = new Map();
    this.metrics = {
      totalRequests: 0,
      limitedRequests: 0,
      bypassedRequests: 0,
      errors: 0,
      adaptiveAdjustments: 0
    };
    this.userMetrics = new Map();
    this.concurrentRequests = new Map();
    this.costTracking = new Map();
    this.anomalyDetection = {
      patterns: new Map(),
      alerts: []
    };

    this.initialize();
  }

  /**
   * Initialize the rate limiting system
   */
  async initialize() {
    try {
      // Initialize Redis connection if enabled
      if (this.options.useRedis) {
        await this.initializeRedis();
      }

      // Initialize rate limiters
      await this.initializeLimiters();

      // Start background processes
      this.startMetricsCollection();
      this.startCleanupProcess();

      if (this.options.enableAnomalyDetection) {
        this.startAnomalyDetection();
      }

      this.emit('initialized');
    } catch (error) {
      this.emit('error', error);
      throw error;
    }
  }

  /**
   * Initialize Redis connection
   */
  async initializeRedis() {
    try {
      this.redis = new Redis(this.options.redis);
      
      this.redis.on('error', (error) => {
        this.emit('redisError', error);
        console.warn('Redis connection error:', error.message);
      });

      this.redis.on('connect', () => {
        this.emit('redisConnected');
      });

      // Test connection
      await this.redis.ping();
    } catch (error) {
      console.warn('Redis initialization failed, falling back to memory:', error.message);
      this.redis = null;
      this.options.useRedis = false;
    }
  }

  /**
   * Initialize rate limiters for different strategies
   */
  async initializeLimiters() {
    const LimiterClass = this.redis ? RateLimiterRedis : RateLimiterMemory;
    const storeConfig = this.redis ? { storeClient: this.redis } : {};

    // Fixed window limiters
    if (this.options.strategies.fixedWindow.enabled) {
      this.limiters.set('fixedWindow', new LimiterClass({
        ...storeConfig,
        keyGenerator: (req, res) => this.generateKey(req, 'fixed'),
        points: this.options.strategies.fixedWindow.maxRequests,
        duration: this.options.strategies.fixedWindow.windowSizeMs / 1000,
        blockDuration: 60, // Block for 1 minute when limit exceeded
        ...this.options.strategies.fixedWindow
      }));
    }

    // Sliding window limiters
    if (this.options.strategies.slidingWindow.enabled) {
      this.limiters.set('slidingWindow', new LimiterClass({
        ...storeConfig,
        keyGenerator: (req, res) => this.generateKey(req, 'sliding'),
        points: this.options.strategies.slidingWindow.maxRequests,
        duration: this.options.strategies.slidingWindow.windowSizeMs / 1000,
        blockDuration: 60,
        ...this.options.strategies.slidingWindow
      }));
    }

    // Token bucket limiter (using RateLimiterMemory)
    if (this.options.strategies.tokenBucket.enabled) {
      this.limiters.set('tokenBucket', new LimiterClass({
        ...storeConfig,
        keyGenerator: (req, res) => this.generateKey(req, 'token'),
        points: this.options.strategies.tokenBucket.capacity,
        duration: 1, // 1 second
        blockDuration: 1,
        execEvenly: true, // Spread requests evenly
        ...this.options.strategies.tokenBucket
      }));
    }

    // Per-tier limiters
    for (const [tier, limits] of Object.entries(this.options.tiers)) {
      this.limiters.set(`tier:${tier}:hourly`, new LimiterClass({
        ...storeConfig,
        keyGenerator: (req, res) => this.generateKey(req, `tier:${tier}:hourly`),
        points: limits.requestsPerHour,
        duration: 3600, // 1 hour
        blockDuration: 300 // Block for 5 minutes
      }));

      this.limiters.set(`tier:${tier}:minute`, new LimiterClass({
        ...storeConfig,
        keyGenerator: (req, res) => this.generateKey(req, `tier:${tier}:minute`),
        points: limits.requestsPerMinute,
        duration: 60, // 1 minute
        blockDuration: 60 // Block for 1 minute
      }));

      this.limiters.set(`tier:${tier}:concurrent`, new LimiterClass({
        ...storeConfig,
        keyGenerator: (req, res) => this.generateKey(req, `tier:${tier}:concurrent`),
        points: limits.concurrentRequests,
        duration: 1, // 1 second
        blockDuration: 1,
        execEvenly: false
      }));
    }

    // Global limiter
    this.limiters.set('global', new LimiterClass({
      ...storeConfig,
      keyGenerator: () => 'global',
      points: this.options.defaultLimits.global.requests,
      duration: this.options.defaultLimits.global.window,
      blockDuration: 60
    }));
  }

  /**
   * Generate rate limiting key
   */
  generateKey(req, strategy) {
    const parts = [strategy];

    // Add user identifier
    if (req.user?.id) {
      parts.push('user', req.user.id);
    } else if (req.apiKey?.id) {
      parts.push('apikey', req.apiKey.id);
    } else {
      parts.push('ip', this.getClientIP(req));
    }

    // Add additional context
    if (req.route?.path) {
      parts.push('route', req.route.path.replace(/[^a-zA-Z0-9]/g, '_'));
    }

    return parts.join(':');
  }

  /**
   * Get client IP address
   */
  getClientIP(req) {
    return req.ip || 
           req.connection?.remoteAddress || 
           req.socket?.remoteAddress || 
           req.headers['x-forwarded-for']?.split(',')[0]?.trim() ||
           req.headers['x-real-ip'] ||
           'unknown';
  }

  /**
   * Check rate limits for a request
   */
  async checkRateLimit(req, res, options = {}) {
    try {
      this.metrics.totalRequests++;
      
      const startTime = Date.now();
      const results = [];

      // Determine user tier
      const tier = this.getUserTier(req);
      const tierLimits = this.options.tiers[tier];

      // Global rate limit check
      if (this.limiters.has('global')) {
        const globalResult = await this.limiters.get('global').consume(this.generateKey(req, 'global'));
        results.push({ type: 'global', result: globalResult });
      }

      // Tier-based checks
      const tierChecks = [
        { key: `tier:${tier}:hourly`, cost: options.cost || 1 },
        { key: `tier:${tier}:minute`, cost: options.cost || 1 },
        { key: `tier:${tier}:concurrent`, cost: 1 }
      ];

      for (const check of tierChecks) {
        if (this.limiters.has(check.key)) {
          const result = await this.limiters.get(check.key).consume(
            this.generateKey(req, check.key), 
            check.cost * tierLimits.costMultiplier
          );
          results.push({ type: check.key, result });
        }
      }

      // Strategy-based checks
      const strategies = ['fixedWindow', 'slidingWindow', 'tokenBucket'];
      for (const strategy of strategies) {
        if (this.limiters.has(strategy) &amp;&amp; this.options.strategies[strategy].enabled) {
          const result = await this.limiters.get(strategy).consume(
            this.generateKey(req, strategy),
            options.cost || 1
          );
          results.push({ type: strategy, result });
        }
      }

      // Adaptive rate limiting
      if (this.options.enableAdaptiveRateLimiting) {
        await this.applyAdaptiveRateLimiting(req, results);
      }

      // Cost-based limiting
      if (this.options.enableCostBasedLimiting &amp;&amp; options.cost) {
        await this.trackCost(req, options.cost);
      }

      // Anomaly detection
      if (this.options.enableAnomalyDetection) {
        this.detectAnomalies(req);
      }

      // Update metrics
      this.updateUserMetrics(req, {
        processed: true,
        cost: options.cost || 1,
        duration: Date.now() - startTime
      });

      // Track concurrent requests
      this.trackConcurrentRequest(req, true);

      // Set rate limit headers
      this.setRateLimitHeaders(res, results, tier);

      this.emit('requestProcessed', { req, results, tier });

      return {
        allowed: true,
        results,
        tier,
        cost: options.cost || 1
      };

    } catch (error) {
      if (error.name === 'RateLimiterError' || error.remainingPoints !== undefined) {
        // Rate limit exceeded
        this.metrics.limitedRequests++;
        
        this.setRateLimitHeaders(res, [{ type: 'limit', result: error }], this.getUserTier(req));
        
        this.emit('rateLimitExceeded', { req, error });
        
        return {
          allowed: false,
          error: error,
          retryAfter: Math.round(error.msBeforeNext / 1000) || 60,
          tier: this.getUserTier(req)
        };
      }

      this.metrics.errors++;
      this.emit('error', error);
      throw error;
    } finally {
      this.trackConcurrentRequest(req, false);
    }
  }

  /**
   * Get user tier based on authentication
   */
  getUserTier(req) {
    if (req.user?.tier) {
      return req.user.tier;
    }
    
    if (req.user?.role === 'admin') {
      return 'enterprise';
    }
    
    if (req.apiKey) {
      return req.apiKey.tier || 'basic';
    }
    
    if (req.user) {
      return 'basic';
    }
    
    return 'free';
  }

  /**
   * Apply adaptive rate limiting
   */
  async applyAdaptiveRateLimiting(req, results) {
    const key = this.generateKey(req, 'adaptive');
    let metrics = this.userMetrics.get(key) || {
      requests: 0,
      errors: 0,
      avgLatency: 0,
      currentLimit: this.options.strategies.adaptive.baseLimit
    };

    // Calculate error rate
    const errorRate = metrics.requests > 0 ? metrics.errors / metrics.requests : 0;
    
    // Adjust limits based on performance
    if (errorRate > this.options.strategies.adaptive.errorThreshold) {
      // Increase limits if error rate is high (server struggling)
      metrics.currentLimit = Math.min(
        metrics.currentLimit * (1 + this.options.strategies.adaptive.adjustmentFactor),
        this.options.strategies.adaptive.maxLimit
      );
      this.metrics.adaptiveAdjustments++;
    } else if (errorRate &lt; this.options.strategies.adaptive.successThreshold) {
      // Decrease limits if performing well
      metrics.currentLimit = Math.max(
        metrics.currentLimit * (1 - this.options.strategies.adaptive.adjustmentFactor),
        this.options.strategies.adaptive.minLimit
      );
      this.metrics.adaptiveAdjustments++;
    }

    this.userMetrics.set(key, metrics);
  }

  /**
   * Track request cost
   */
  async trackCost(req, cost) {
    const key = this.generateKey(req, 'cost');
    const current = this.costTracking.get(key) || { total: 0, requests: 0, window: Date.now() };
    
    // Reset window if older than 1 hour
    if (Date.now() - current.window > 3600000) {
      current.total = 0;
      current.requests = 0;
      current.window = Date.now();
    }
    
    current.total += cost;
    current.requests++;
    
    this.costTracking.set(key, current);
  }

  /**
   * Detect anomalous patterns
   */
  detectAnomalies(req) {
    const ip = this.getClientIP(req);
    const pattern = this.anomalyDetection.patterns.get(ip) || {
      requests: [],
      firstSeen: Date.now(),
      countries: new Set(),
      userAgents: new Set()
    };

    const now = Date.now();
    pattern.requests.push(now);
    
    // Keep only requests from last hour
    pattern.requests = pattern.requests.filter(time => now - time &lt; 3600000);
    
    // Track user agents and potential geo data
    if (req.headers['user-agent']) {
      pattern.userAgents.add(req.headers['user-agent']);
    }

    // Detect suspicious patterns
    const requestsLastMinute = pattern.requests.filter(time => now - time &lt; 60000).length;
    const requestsLastHour = pattern.requests.length;
    
    if (requestsLastMinute > 100 || 
        requestsLastHour > 1000 || 
        pattern.userAgents.size > 10) {
      
      this.anomalyDetection.alerts.push({
        ip,
        type: 'suspicious_activity',
        details: {
          requestsLastMinute,
          requestsLastHour,
          userAgents: pattern.userAgents.size
        },
        timestamp: now
      });
      
      this.emit('anomalyDetected', {
        ip,
        pattern,
        metrics: { requestsLastMinute, requestsLastHour }
      });
    }

    this.anomalyDetection.patterns.set(ip, pattern);
  }

  /**
   * Update user metrics
   */
  updateUserMetrics(req, data) {
    const key = this.generateKey(req, 'metrics');
    const metrics = this.userMetrics.get(key) || {
      requests: 0,
      errors: 0,
      totalCost: 0,
      avgLatency: 0,
      firstSeen: Date.now(),
      lastSeen: Date.now()
    };

    metrics.requests++;
    metrics.lastSeen = Date.now();
    
    if (data.cost) {
      metrics.totalCost += data.cost;
    }
    
    if (data.duration) {
      metrics.avgLatency = (metrics.avgLatency * (metrics.requests - 1) + data.duration) / metrics.requests;
    }

    this.userMetrics.set(key, metrics);
  }

  /**
   * Track concurrent requests
   */
  trackConcurrentRequest(req, isStart) {
    const key = this.generateKey(req, 'concurrent');
    const current = this.concurrentRequests.get(key) || 0;
    
    if (isStart) {
      this.concurrentRequests.set(key, current + 1);
    } else {
      this.concurrentRequests.set(key, Math.max(0, current - 1));
    }
  }

  /**
   * Set rate limit headers
   */
  setRateLimitHeaders(res, results, tier) {
    const tierLimits = this.options.tiers[tier];
    const mostRestrictive = results.reduce((min, current) => {
      const remaining = current.result?.remainingPoints || current.result?.totalHits || 0;
      return remaining &lt; (min?.remainingPoints || Infinity) ? current.result : min;
    }, null);

    if (mostRestrictive) {
      res.set({
        'X-RateLimit-Limit': tierLimits.requestsPerHour,
        'X-RateLimit-Remaining': Math.max(0, mostRestrictive.remainingPoints || 0),
        'X-RateLimit-Reset': new Date(Date.now() + (mostRestrictive.msBeforeNext || 0)),
        'X-RateLimit-Tier': tier,
        'X-RateLimit-Cost': 1 // Could be dynamic based on operation
      });
    }
  }

  /**
   * Create rate limiting middleware
   */
  createMiddleware(options = {}) {
    return async (req, res, next) => {
      try {
        const result = await this.checkRateLimit(req, res, options);
        
        if (!result.allowed) {
          return res.status(429).json({
            error: 'Rate limit exceeded',
            message: `Too many requests. Try again in ${result.retryAfter} seconds.`,
            retryAfter: result.retryAfter,
            tier: result.tier
          });
        }

        // Add rate limit info to request
        req.rateLimit = result;
        next();
      } catch (error) {
        this.emit('middlewareError', error);
        // Fail open - allow request to proceed if rate limiting fails
        next();
      }
    };
  }

  /**
   * Create tier-specific middleware
   */
  createTierMiddleware(tier, options = {}) {
    return this.createMiddleware({
      ...options,
      forceTier: tier
    });
  }

  /**
   * Create cost-based middleware
   */
  createCostMiddleware(costCalculator) {
    return async (req, res, next) => {
      try {
        const cost = typeof costCalculator === 'function' ? 
          await costCalculator(req) : costCalculator;
        
        const result = await this.checkRateLimit(req, res, { cost });
        
        if (!result.allowed) {
          return res.status(429).json({
            error: 'Rate limit exceeded',
            message: `Cost limit exceeded. Operation cost: ${cost}`,
            retryAfter: result.retryAfter,
            cost: cost
          });
        }

        req.rateLimit = result;
        next();
      } catch (error) {
        this.emit('middlewareError', error);
        next();
      }
    };
  }

  /**
   * Bypass rate limiting for specific conditions
   */
  createBypassMiddleware(conditions) {
    return (req, res, next) => {
      const shouldBypass = conditions.some(condition => {
        if (typeof condition === 'function') {
          return condition(req);
        }
        if (typeof condition === 'string') {
          return req.user?.role === condition || req.ip === condition;
        }
        return false;
      });

      if (shouldBypass) {
        this.metrics.bypassedRequests++;
        req.rateLimit = { bypassed: true };
        return next();
      }

      next();
    };
  }

  /**
   * Get rate limiting statistics
   */
  getStats() {
    const userCount = this.userMetrics.size;
    const activeUsers = Array.from(this.userMetrics.values())
      .filter(m => Date.now() - m.lastSeen &lt; 300000).length; // Active in last 5 minutes

    const totalConcurrent = Array.from(this.concurrentRequests.values())
      .reduce((sum, count) => sum + count, 0);

    return {
      ...this.metrics,
      userCount,
      activeUsers,
      totalConcurrent,
      anomalies: this.anomalyDetection.alerts.length,
      redis: this.redis ? 'connected' : 'memory'
    };
  }

  /**
   * Get user-specific statistics
   */
  getUserStats(identifier) {
    const metrics = Array.from(this.userMetrics.entries())
      .filter(([key]) => key.includes(identifier))
      .map(([key, metrics]) => ({ key, ...metrics }));

    const costs = Array.from(this.costTracking.entries())
      .filter(([key]) => key.includes(identifier))
      .map(([key, cost]) => ({ key, ...cost }));

    return { metrics, costs };
  }

  /**
   * Reset user limits (admin function)
   */
  async resetUserLimits(identifier) {
    const keys = [];
    
    // Collect all keys for this user
    for (const [key] of this.userMetrics) {
      if (key.includes(identifier)) {
        keys.push(key);
      }
    }

    // Reset in Redis if available
    if (this.redis) {
      const pipeline = this.redis.pipeline();
      for (const key of keys) {
        pipeline.del(`${this.options.redis.keyPrefix}${key}`);
      }
      await pipeline.exec();
    }

    // Reset in memory
    for (const key of keys) {
      this.userMetrics.delete(key);
      this.costTracking.delete(key);
      this.concurrentRequests.delete(key);
    }

    this.emit('userLimitsReset', { identifier, keysReset: keys.length });
    return keys.length;
  }

  /**
   * Start metrics collection
   */
  startMetricsCollection() {
    setInterval(() => {
      this.emit('metricsCollected', this.getStats());
    }, 60000); // Every minute
  }

  /**
   * Start cleanup process
   */
  startCleanupProcess() {
    setInterval(() => {
      this.cleanup();
    }, 300000); // Every 5 minutes
  }

  /**
   * Start anomaly detection
   */
  startAnomalyDetection() {
    setInterval(() => {
      this.analyzePatterns();
    }, 60000); // Every minute
  }

  /**
   * Analyze patterns for anomalies
   */
  analyzePatterns() {
    const now = Date.now();
    const hourAgo = now - 3600000;

    // Clean old patterns
    for (const [ip, pattern] of this.anomalyDetection.patterns) {
      pattern.requests = pattern.requests.filter(time => time > hourAgo);
      if (pattern.requests.length === 0) {
        this.anomalyDetection.patterns.delete(ip);
      }
    }

    // Clean old alerts
    this.anomalyDetection.alerts = this.anomalyDetection.alerts
      .filter(alert => now - alert.timestamp &lt; 86400000); // Keep for 24 hours
  }

  /**
   * Cleanup expired data
   */
  cleanup() {
    const now = Date.now();
    const hourAgo = now - 3600000;

    // Clean user metrics
    for (const [key, metrics] of this.userMetrics) {
      if (now - metrics.lastSeen > hourAgo) {
        this.userMetrics.delete(key);
      }
    }

    // Clean cost tracking
    for (const [key, cost] of this.costTracking) {
      if (now - cost.window > hourAgo) {
        this.costTracking.delete(key);
      }
    }

    // Clean concurrent requests
    for (const [key, count] of this.concurrentRequests) {
      if (count === 0) {
        this.concurrentRequests.delete(key);
      }
    }

    this.emit('cleanupCompleted');
  }

  /**
   * Shutdown rate limiter
   */
  async shutdown() {
    if (this.redis) {
      await this.redis.quit();
    }
    this.emit('shutdown');
  }
}

export default RateLimitManager;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ABTestingManager.html">ABTestingManager</a></li><li><a href="AuditLogger.html">AuditLogger</a></li><li><a href="AuthMiddleware.html">AuthMiddleware</a></li><li><a href="BPETokenizer.html">BPETokenizer</a></li><li><a href="BaseEngine.html">BaseEngine</a></li><li><a href="BaseLoader.html">BaseLoader</a></li><li><a href="BinaryLoader.html">BinaryLoader</a></li><li><a href="BinaryModel.html">BinaryModel</a></li><li><a href="BitNetLoader.html">BitNetLoader</a></li><li><a href="ConversionConfig.html">ConversionConfig</a></li><li><a href="ConversionResult.html">ConversionResult</a></li><li><a href="EnterpriseAuthManager.html">EnterpriseAuthManager</a></li><li><a href="EnterpriseManager.html">EnterpriseManager</a></li><li><a href="EnterpriseRouter.html">EnterpriseRouter</a></li><li><a href="FormatConverter.html">FormatConverter</a></li><li><a href="GGUFLoader.html">GGUFLoader</a></li><li><a href="GGUFModel.html">GGUFModel</a></li><li><a href="GRPCClient.html">GRPCClient</a></li><li><a href="LLMRouter.html">LLMRouter</a></li><li><a href="MockLoader.html">MockLoader</a></li><li><a href="MockModel.html">MockModel</a></li><li><a href="ModelInterface.html">ModelInterface</a></li><li><a href="ModelQuantizer.html">ModelQuantizer</a></li><li><a href="ModelTemplates.html">ModelTemplates</a></li><li><a href="MultiTenancyManager.html">MultiTenancyManager</a></li><li><a href="PyTorchLoader.html">PyTorchLoader</a></li><li><a href="PyTorchModel.html">PyTorchModel</a></li><li><a href="QuantizationConfig.html">QuantizationConfig</a></li><li><a href="QuantizationResult.html">QuantizationResult</a></li><li><a href="Router.html">Router</a></li><li><a href="SLAMonitor.html">SLAMonitor</a></li><li><a href="SentencePieceTokenizer.html">SentencePieceTokenizer</a></li><li><a href="SimpleLoader.html">SimpleLoader</a></li><li><a href="SimpleModel.html">SimpleModel</a></li><li><a href="TokenizationResult.html">TokenizationResult</a></li><li><a href="TokenizerConfig.html">TokenizerConfig</a></li><li><a href="UniversalTokenizer.html">UniversalTokenizer</a></li><li><a href="ValidationConfig.html">ValidationConfig</a></li><li><a href="ValidationSuite.html">ValidationSuite</a></li><li><a href="ValidationSuiteResult.html">ValidationSuiteResult</a></li><li><a href="ValidationTestResult.html">ValidationTestResult</a></li><li><a href="WordPieceTokenizer.html">WordPieceTokenizer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Architectures">Architectures</a></li><li><a href="global.html#AuditEventTypes">AuditEventTypes</a></li><li><a href="global.html#AuthMethods">AuthMethods</a></li><li><a href="global.html#BreachSeverity">BreachSeverity</a></li><li><a href="global.html#Capabilities">Capabilities</a></li><li><a href="global.html#ComplianceFrameworks">ComplianceFrameworks</a></li><li><a href="global.html#EnterpriseFeatures">EnterpriseFeatures</a></li><li><a href="global.html#ExperimentStatus">ExperimentStatus</a></li><li><a href="global.html#IsolationLevels">IsolationLevels</a></li><li><a href="global.html#ModelFormat">ModelFormat</a></li><li><a href="global.html#ModelFormats">ModelFormats</a></li><li><a href="global.html#Permissions">Permissions</a></li><li><a href="global.html#QuantizationMethod">QuantizationMethod</a></li><li><a href="global.html#QuantizationPrecision">QuantizationPrecision</a></li><li><a href="global.html#QuotaTypes">QuotaTypes</a></li><li><a href="global.html#RiskLevels">RiskLevels</a></li><li><a href="global.html#RoutingStrategies">RoutingStrategies</a></li><li><a href="global.html#SLAMetricTypes">SLAMetricTypes</a></li><li><a href="global.html#SLAStatus">SLAStatus</a></li><li><a href="global.html#SessionTypes">SessionTypes</a></li><li><a href="global.html#SplittingAlgorithms">SplittingAlgorithms</a></li><li><a href="global.html#StatisticalTests">StatisticalTests</a></li><li><a href="global.html#TimeWindows">TimeWindows</a></li><li><a href="global.html#TokenizerType">TokenizerType</a></li><li><a href="global.html#UserRoles">UserRoles</a></li><li><a href="global.html#ValidationSeverity">ValidationSeverity</a></li><li><a href="global.html#ValidationTestType">ValidationTestType</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#createEnterpriseExpressRoutes">createEnterpriseExpressRoutes</a></li><li><a href="global.html#createEnterpriseRouter">createEnterpriseRouter</a></li><li><a href="global.html#createEnterpriseWebSocketHandlers">createEnterpriseWebSocketHandlers</a></li><li><a href="global.html#defaultEnterpriseConfig">defaultEnterpriseConfig</a></li><li><a href="global.html#enterpriseVersion">enterpriseVersion</a></li><li><a href="global.html#errorMonitoringMiddleware">errorMonitoringMiddleware</a></li><li><a href="global.html#getEnabledFeatures">getEnabledFeatures</a></li><li><a href="global.html#getMonitoringStatus">getMonitoringStatus</a></li><li><a href="global.html#httpMonitoringMiddleware">httpMonitoringMiddleware</a></li><li><a href="global.html#isFeatureEnabled">isFeatureEnabled</a></li><li><a href="global.html#recordCustomMetric">recordCustomMetric</a></li><li><a href="global.html#registerAlertRule">registerAlertRule</a></li><li><a href="global.html#registerDependency">registerDependency</a></li><li><a href="global.html#registerHealthCheck">registerHealthCheck</a></li><li><a href="global.html#setupMonitoring">setupMonitoring</a></li><li><a href="global.html#startPerformanceProfile">startPerformanceProfile</a></li><li><a href="global.html#validateEnterpriseConfig">validateEnterpriseConfig</a></li><li><a href="global.html#withCacheMonitoring">withCacheMonitoring</a></li><li><a href="global.html#withDatabaseMonitoring">withDatabaseMonitoring</a></li><li><a href="global.html#withModelMonitoring">withModelMonitoring</a></li><li><a href="global.html#withQueueMonitoring">withQueueMonitoring</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sun Aug 17 2025 22:28:58 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
