<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/PerformanceBenchmark.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/PerformanceBenchmark.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * 🏃‍♂️ Performance Benchmark - Speed of Thought Measurement
 * Comprehensive benchmarking system for LLM provider performance
 * Echo AI Systems - Measuring excellence across dimensions
 */

import { Logger } from './Logger.js';
import { performance } from 'perf_hooks';

const logger = new Logger('PerformanceBenchmark');

class PerformanceBenchmark {
  constructor() {
    this.benchmarkHistory = new Map();
    this.activeMetrics = new Map();
    this.baselineMetrics = new Map();
    
    // Standard benchmark prompts for different categories
    this.benchmarkPrompts = {
      simple: "Hello, how are you?",
      medium: "Explain the concept of machine learning in simple terms for a beginner.",
      complex: "Write a detailed analysis of the economic implications of artificial intelligence on global employment patterns, considering both short-term disruptions and long-term adaptations across different industries and skill levels.",
      code: "Write a Python function that implements a binary search algorithm with proper error handling and documentation.",
      creative: "Write a short story about a robot who discovers emotions for the first time.",
      reasoning: "If a train leaves New York at 3 PM traveling at 120 mph, and another train leaves Boston at 4 PM traveling at 100 mph toward New York, and the distance between the cities is 200 miles, when and where will they meet?"
    };

    // Performance thresholds for quality assessment
    this.performanceThresholds = {
      excellent: { latency: 500, throughput: 100, errorRate: 0.001 },
      good: { latency: 1000, throughput: 50, errorRate: 0.01 },
      acceptable: { latency: 2000, throughput: 25, errorRate: 0.05 },
      poor: { latency: 5000, throughput: 10, errorRate: 0.1 }
    };
  }

  /**
   * Run comprehensive benchmark suite for a provider
   */
  async runBenchmarkSuite(adapter, options = {}) {
    const suiteId = `${adapter.provider}-${Date.now()}`;
    logger.info(`🏃‍♂️ Starting benchmark suite ${suiteId}`);

    const results = {
      suiteId,
      provider: adapter.provider,
      timestamp: new Date().toISOString(),
      systemInfo: await this.getSystemInfo(),
      tests: {},
      summary: {}
    };

    try {
      // Test different prompt categories
      for (const [category, prompt] of Object.entries(this.benchmarkPrompts)) {
        if (options.categories &amp;&amp; !options.categories.includes(category)) {
          continue;
        }

        logger.info(`Testing ${category} prompts...`);
        results.tests[category] = await this.runCategoryBenchmark(
          adapter, 
          category, 
          prompt, 
          options
        );
      }

      // Run stress tests if requested
      if (options.includeStressTest) {
        results.tests.stress = await this.runStressTest(adapter, options);
      }

      // Run concurrency tests if requested
      if (options.includeConcurrencyTest) {
        results.tests.concurrency = await this.runConcurrencyTest(adapter, options);
      }

      // Generate summary metrics
      results.summary = this.generateSummary(results.tests);
      
      // Store results
      this.storeBenchmarkResults(suiteId, results);
      
      logger.info(`✅ Benchmark suite ${suiteId} completed`);
      return results;

    } catch (error) {
      logger.error(`❌ Benchmark suite ${suiteId} failed:`, error);
      results.error = error.message;
      return results;
    }
  }

  /**
   * Run benchmark for specific prompt category
   */
  async runCategoryBenchmark(adapter, category, prompt, options = {}) {
    const iterations = options.iterations || 3;
    const warmup = options.warmup || 1;
    const results = {
      category,
      prompt: prompt.slice(0, 100) + '...',
      iterations,
      runs: [],
      metrics: {}
    };

    // Warmup runs
    logger.debug(`Warming up with ${warmup} runs...`);
    for (let i = 0; i &lt; warmup; i++) {
      try {
        await this.measureSingleRun(adapter, prompt, { timeout: 30000 });
      } catch (error) {
        logger.warn(`Warmup run ${i + 1} failed:`, error.message);
      }
    }

    // Actual benchmark runs
    for (let i = 0; i &lt; iterations; i++) {
      logger.debug(`Running iteration ${i + 1}/${iterations}...`);
      
      try {
        const runResult = await this.measureSingleRun(adapter, prompt, options);
        results.runs.push(runResult);
        
        // Brief pause between runs
        await this.sleep(1000);
      } catch (error) {
        logger.warn(`Run ${i + 1} failed:`, error.message);
        results.runs.push({
          iteration: i + 1,
          success: false,
          error: error.message,
          metrics: {}
        });
      }
    }

    // Calculate aggregate metrics
    results.metrics = this.calculateAggregateMetrics(results.runs);
    results.performanceGrade = this.assessPerformance(results.metrics);

    return results;
  }

  /**
   * Measure performance of a single run
   */
  async measureSingleRun(adapter, prompt, options = {}) {
    const startTime = performance.now();
    const startMemory = process.memoryUsage();
    
    let firstTokenTime = null;
    let tokenCount = 0;
    let success = false;
    let error = null;
    let response = null;

    try {
      // Set up timeout
      const timeout = options.timeout || 30000;
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Request timeout')), timeout)
      );

      // Start the actual request
      const requestPromise = this.makeRequest(adapter, prompt, {
        onFirstToken: () => { firstTokenTime = performance.now(); },
        onToken: () => { tokenCount++; }
      });

      response = await Promise.race([requestPromise, timeoutPromise]);
      success = true;

    } catch (err) {
      error = err.message;
      logger.warn(`Request failed: ${error}`);
    }

    const endTime = performance.now();
    const endMemory = process.memoryUsage();

    // Calculate metrics
    const totalLatency = endTime - startTime;
    const firstTokenLatency = firstTokenTime ? firstTokenTime - startTime : null;
    const tokensPerSecond = tokenCount > 0 ? (tokenCount / (totalLatency / 1000)) : 0;
    const memoryDelta = endMemory.heapUsed - startMemory.heapUsed;

    return {
      success,
      error,
      metrics: {
        totalLatency: Math.round(totalLatency),
        firstTokenLatency: firstTokenLatency ? Math.round(firstTokenLatency) : null,
        tokenCount,
        tokensPerSecond: Math.round(tokensPerSecond * 100) / 100,
        memoryUsageMB: Math.round(memoryDelta / 1024 / 1024 * 100) / 100,
        responseLength: response ? response.length : 0
      },
      response: response ? response.slice(0, 200) + '...' : null
    };
  }

  /**
   * Make request to adapter with performance monitoring
   */
  async makeRequest(adapter, prompt, callbacks = {}) {
    let tokenCount = 0;
    let firstToken = false;

    // Try to use streaming if available
    if (adapter.stream &amp;&amp; typeof adapter.stream === 'function') {
      let fullResponse = '';
      
      const stream = adapter.stream(prompt, {
        maxTokens: 100, // Limit for benchmarking
        temperature: 0.7
      });

      for await (const chunk of stream) {
        if (!firstToken &amp;&amp; callbacks.onFirstToken) {
          callbacks.onFirstToken();
          firstToken = true;
        }
        
        if (chunk.text) {
          fullResponse += chunk.text;
          tokenCount++;
          if (callbacks.onToken) callbacks.onToken();
        }
      }
      
      return fullResponse;
    } else {
      // Fallback to complete method
      const response = await adapter.complete(prompt, {
        maxTokens: 100,
        temperature: 0.7
      });
      
      if (callbacks.onFirstToken) callbacks.onFirstToken();
      return response.text || response.content || String(response);
    }
  }

  /**
   * Run stress test with increasing load
   */
  async runStressTest(adapter, options = {}) {
    const maxConcurrency = options.maxConcurrency || 10;
    const duration = options.stressDuration || 60000; // 1 minute
    const results = {
      type: 'stress',
      duration,
      maxConcurrency,
      stages: []
    };

    logger.info(`🔥 Starting stress test (max ${maxConcurrency} concurrent, ${duration}ms)`);

    for (let concurrency = 1; concurrency &lt;= maxConcurrency; concurrency++) {
      logger.info(`Testing concurrency level: ${concurrency}`);
      
      const stageResult = await this.runConcurrentRequests(
        adapter, 
        concurrency, 
        Math.min(duration / maxConcurrency, 10000),
        options
      );
      
      results.stages.push({
        concurrency,
        ...stageResult
      });

      // Stop if error rate gets too high
      if (stageResult.errorRate > 0.5) {
        logger.warn(`Stopping stress test at concurrency ${concurrency} due to high error rate`);
        break;
      }
    }

    return results;
  }

  /**
   * Run concurrency test
   */
  async runConcurrencyTest(adapter, options = {}) {
    const concurrencyLevels = options.concurrencyLevels || [1, 2, 5, 10];
    const results = {
      type: 'concurrency',
      levels: []
    };

    for (const level of concurrencyLevels) {
      logger.info(`Testing concurrency level: ${level}`);
      
      const levelResult = await this.runConcurrentRequests(
        adapter, 
        level, 
        10000, // 10 second test
        options
      );
      
      results.levels.push({
        concurrency: level,
        ...levelResult
      });
    }

    return results;
  }

  /**
   * Run concurrent requests
   */
  async runConcurrentRequests(adapter, concurrency, duration, options = {}) {
    const prompt = this.benchmarkPrompts.medium;
    const requests = [];
    const results = [];
    const startTime = performance.now();

    // Start concurrent requests
    for (let i = 0; i &lt; concurrency; i++) {
      const requestPromise = this.measureSingleRun(adapter, prompt, options)
        .then(result => {
          results.push(result);
          return result;
        })
        .catch(error => {
          const errorResult = { success: false, error: error.message, metrics: {} };
          results.push(errorResult);
          return errorResult;
        });
      
      requests.push(requestPromise);
    }

    // Wait for all requests to complete or timeout
    await Promise.allSettled(requests);
    
    const totalTime = performance.now() - startTime;
    const successful = results.filter(r => r.success);
    const failed = results.filter(r => !r.success);

    return {
      totalRequests: results.length,
      successful: successful.length,
      failed: failed.length,
      errorRate: failed.length / results.length,
      averageLatency: successful.length > 0 ? 
        successful.reduce((sum, r) => sum + r.metrics.totalLatency, 0) / successful.length : 0,
      requestsPerSecond: results.length / (totalTime / 1000),
      totalDuration: totalTime
    };
  }

  /**
   * Calculate aggregate metrics from multiple runs
   */
  calculateAggregateMetrics(runs) {
    const successful = runs.filter(r => r.success);
    
    if (successful.length === 0) {
      return {
        successRate: 0,
        averageLatency: 0,
        medianLatency: 0,
        p95Latency: 0,
        averageTokensPerSecond: 0,
        totalTokens: 0
      };
    }

    const latencies = successful.map(r => r.metrics.totalLatency).sort((a, b) => a - b);
    const tokenSpeeds = successful.map(r => r.metrics.tokensPerSecond);
    const tokens = successful.map(r => r.metrics.tokenCount);

    return {
      successRate: successful.length / runs.length,
      averageLatency: Math.round(latencies.reduce((a, b) => a + b, 0) / latencies.length),
      medianLatency: latencies[Math.floor(latencies.length / 2)],
      p95Latency: latencies[Math.floor(latencies.length * 0.95)],
      averageTokensPerSecond: Math.round((tokenSpeeds.reduce((a, b) => a + b, 0) / tokenSpeeds.length) * 100) / 100,
      totalTokens: tokens.reduce((a, b) => a + b, 0),
      minLatency: Math.min(...latencies),
      maxLatency: Math.max(...latencies)
    };
  }

  /**
   * Assess performance grade based on metrics
   */
  assessPerformance(metrics) {
    const { averageLatency, successRate, averageTokensPerSecond } = metrics;
    
    if (successRate &lt; 0.9) return 'poor';
    
    for (const [grade, thresholds] of Object.entries(this.performanceThresholds)) {
      if (averageLatency &lt;= thresholds.latency &amp;&amp; 
          averageTokensPerSecond >= thresholds.throughput) {
        return grade;
      }
    }
    
    return 'poor';
  }

  /**
   * Generate summary from all test results
   */
  generateSummary(tests) {
    const summary = {
      overallGrade: 'poor',
      categoryGrades: {},
      averageMetrics: {},
      recommendations: []
    };

    const grades = [];
    const allMetrics = {
      latency: [],
      throughput: [],
      successRate: []
    };

    // Collect metrics from all categories
    for (const [category, result] of Object.entries(tests)) {
      if (result.metrics &amp;&amp; result.performanceGrade) {
        summary.categoryGrades[category] = result.performanceGrade;
        grades.push(result.performanceGrade);
        
        allMetrics.latency.push(result.metrics.averageLatency);
        allMetrics.throughput.push(result.metrics.averageTokensPerSecond);
        allMetrics.successRate.push(result.metrics.successRate);
      }
    }

    // Calculate overall grade
    const gradeValues = { excellent: 4, good: 3, acceptable: 2, poor: 1 };
    const avgGradeValue = grades.reduce((sum, grade) => sum + gradeValues[grade], 0) / grades.length;
    
    if (avgGradeValue >= 3.5) summary.overallGrade = 'excellent';
    else if (avgGradeValue >= 2.5) summary.overallGrade = 'good';
    else if (avgGradeValue >= 1.5) summary.overallGrade = 'acceptable';

    // Calculate average metrics
    summary.averageMetrics = {
      latency: allMetrics.latency.length > 0 ? 
        Math.round(allMetrics.latency.reduce((a, b) => a + b, 0) / allMetrics.latency.length) : 0,
      throughput: allMetrics.throughput.length > 0 ? 
        Math.round((allMetrics.throughput.reduce((a, b) => a + b, 0) / allMetrics.throughput.length) * 100) / 100 : 0,
      successRate: allMetrics.successRate.length > 0 ? 
        Math.round((allMetrics.successRate.reduce((a, b) => a + b, 0) / allMetrics.successRate.length) * 100) / 100 : 0
    };

    // Generate recommendations
    summary.recommendations = this.generateRecommendations(summary);

    return summary;
  }

  /**
   * Generate performance recommendations
   */
  generateRecommendations(summary) {
    const recommendations = [];
    const { averageMetrics, overallGrade } = summary;

    if (averageMetrics.successRate &lt; 0.95) {
      recommendations.push('Improve error handling and retry logic');
    }

    if (averageMetrics.latency > 2000) {
      recommendations.push('Consider optimizing request parameters or using faster models');
    }

    if (averageMetrics.throughput &lt; 25) {
      recommendations.push('Consider models with higher token generation speed');
    }

    if (overallGrade === 'poor') {
      recommendations.push('Consider switching to a different provider or model');
    }

    if (recommendations.length === 0) {
      recommendations.push('Performance is satisfactory, consider monitoring for consistency');
    }

    return recommendations;
  }

  /**
   * Compare performance across providers
   */
  compareProviders(results) {
    const comparison = {
      timestamp: new Date().toISOString(),
      providers: {},
      rankings: {},
      insights: []
    };

    // Organize results by provider
    for (const result of results) {
      comparison.providers[result.provider] = {
        overallGrade: result.summary.overallGrade,
        metrics: result.summary.averageMetrics,
        categories: result.summary.categoryGrades
      };
    }

    // Generate rankings
    const metrics = ['latency', 'throughput', 'successRate'];
    for (const metric of metrics) {
      comparison.rankings[metric] = Object.entries(comparison.providers)
        .sort((a, b) => {
          const valueA = a[1].metrics[metric] || 0;
          const valueB = b[1].metrics[metric] || 0;
          return metric === 'latency' ? valueA - valueB : valueB - valueA;
        })
        .map(([provider]) => provider);
    }

    return comparison;
  }

  /**
   * Store benchmark results
   */
  storeBenchmarkResults(suiteId, results) {
    this.benchmarkHistory.set(suiteId, results);
    
    // Keep only last 100 results
    if (this.benchmarkHistory.size > 100) {
      const oldest = this.benchmarkHistory.keys().next().value;
      this.benchmarkHistory.delete(oldest);
    }
  }

  /**
   * Get system information
   */
  async getSystemInfo() {
    return {
      platform: process.platform,
      nodeVersion: process.version,
      memory: process.memoryUsage(),
      cpus: require('os').cpus().length,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Sleep utility
   */
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Get benchmark history
   */
  getBenchmarkHistory() {
    return Array.from(this.benchmarkHistory.values());
  }

  /**
   * Export results to JSON
   */
  exportResults(suiteId) {
    const results = this.benchmarkHistory.get(suiteId);
    if (!results) {
      throw new Error(`Benchmark results not found for suite: ${suiteId}`);
    }
    
    return JSON.stringify(results, null, 2);
  }
}

export default PerformanceBenchmark;
export { PerformanceBenchmark };</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ABTestingManager.html">ABTestingManager</a></li><li><a href="APILoader.html">APILoader</a></li><li><a href="AnthropicAdapter.html">AnthropicAdapter</a></li><li><a href="AuditLogger.html">AuditLogger</a></li><li><a href="AuthManager.html">AuthManager</a></li><li><a href="AuthMiddleware.html">AuthMiddleware</a></li><li><a href="AzureOpenAIAdapter.html">AzureOpenAIAdapter</a></li><li><a href="BPETokenizer.html">BPETokenizer</a></li><li><a href="BaseEngine.html">BaseEngine</a></li><li><a href="BaseLoader.html">BaseLoader</a></li><li><a href="BedrockAdapter.html">BedrockAdapter</a></li><li><a href="BinaryLoader.html">BinaryLoader</a></li><li><a href="BinaryModel.html">BinaryModel</a></li><li><a href="BitNetLoader.html">BitNetLoader</a></li><li><a href="CohereAdapter.html">CohereAdapter</a></li><li><a href="ConversionConfig.html">ConversionConfig</a></li><li><a href="ConversionResult.html">ConversionResult</a></li><li><a href="DeepSeekAdapter.html">DeepSeekAdapter</a></li><li><a href="EnterpriseAuthManager.html">EnterpriseAuthManager</a></li><li><a href="EnterpriseManager.html">EnterpriseManager</a></li><li><a href="EnterpriseRouter.html">EnterpriseRouter</a></li><li><a href="ErrorHandler.html">ErrorHandler</a></li><li><a href="FireworksAdapter.html">FireworksAdapter</a></li><li><a href="FormatConverter.html">FormatConverter</a></li><li><a href="GGUFLoader.html">GGUFLoader</a></li><li><a href="GGUFModel.html">GGUFModel</a></li><li><a href="GRPCClient.html">GRPCClient</a></li><li><a href="GroqAdapter.html">GroqAdapter</a></li><li><a href="LLMRouter.html">LLMRouter</a></li><li><a href="MistralAdapter.html">MistralAdapter</a></li><li><a href="MockLoader.html">MockLoader</a></li><li><a href="MockModel.html">MockModel</a></li><li><a href="ModelError.html">ModelError</a></li><li><a href="ModelInterface.html">ModelInterface</a></li><li><a href="ModelQuantizer.html">ModelQuantizer</a></li><li><a href="ModelRegistry.html">ModelRegistry</a></li><li><a href="ModelTemplates.html">ModelTemplates</a></li><li><a href="MultiTenancyManager.html">MultiTenancyManager</a></li><li><a href="NovitaAdapter.html">NovitaAdapter</a></li><li><a href="OpenAIAdapter.html">OpenAIAdapter</a></li><li><a href="OpenRouterAdapter.html">OpenRouterAdapter</a></li><li><a href="PerplexityAdapter.html">PerplexityAdapter</a></li><li><a href="Pipeline.html">Pipeline</a></li><li><a href="PyTorchLoader.html">PyTorchLoader</a></li><li><a href="PyTorchModel.html">PyTorchModel</a></li><li><a href="QuantizationConfig.html">QuantizationConfig</a></li><li><a href="QuantizationResult.html">QuantizationResult</a></li><li><a href="Router.html">Router</a></li><li><a href="SLAMonitor.html">SLAMonitor</a></li><li><a href="SentencePieceTokenizer.html">SentencePieceTokenizer</a></li><li><a href="SimpleLoader.html">SimpleLoader</a></li><li><a href="SimpleModel.html">SimpleModel</a></li><li><a href="TogetherAdapter.html">TogetherAdapter</a></li><li><a href="TokenizationResult.html">TokenizationResult</a></li><li><a href="TokenizerConfig.html">TokenizerConfig</a></li><li><a href="UniversalTokenizer.html">UniversalTokenizer</a></li><li><a href="ValidationConfig.html">ValidationConfig</a></li><li><a href="ValidationSuite.html">ValidationSuite</a></li><li><a href="ValidationSuiteResult.html">ValidationSuiteResult</a></li><li><a href="ValidationTestResult.html">ValidationTestResult</a></li><li><a href="VertexAIAdapter.html">VertexAIAdapter</a></li><li><a href="WordPieceTokenizer.html">WordPieceTokenizer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ADAPTER_REGISTRY">ADAPTER_REGISTRY</a></li><li><a href="global.html#API_KEY_PATTERNS">API_KEY_PATTERNS</a></li><li><a href="global.html#AUTH_TYPES">AUTH_TYPES</a></li><li><a href="global.html#AZURE_API_VERSIONS">AZURE_API_VERSIONS</a></li><li><a href="global.html#AZURE_OPENAI_MODELS">AZURE_OPENAI_MODELS</a></li><li><a href="global.html#Architectures">Architectures</a></li><li><a href="global.html#AuditEventTypes">AuditEventTypes</a></li><li><a href="global.html#AuthMethods">AuthMethods</a></li><li><a href="global.html#BEDROCK_MODELS">BEDROCK_MODELS</a></li><li><a href="global.html#BreachSeverity">BreachSeverity</a></li><li><a href="global.html#CLAUDE_MODELS">CLAUDE_MODELS</a></li><li><a href="global.html#COHERE_MODELS">COHERE_MODELS</a></li><li><a href="global.html#COMPLIANCE_FEATURES">COMPLIANCE_FEATURES</a></li><li><a href="global.html#Capabilities">Capabilities</a></li><li><a href="global.html#ComplianceFrameworks">ComplianceFrameworks</a></li><li><a href="global.html#DEEPSEEK_ENDPOINTS">DEEPSEEK_ENDPOINTS</a></li><li><a href="global.html#DEEPSEEK_MODELS">DEEPSEEK_MODELS</a></li><li><a href="global.html#EnterpriseFeatures">EnterpriseFeatures</a></li><li><a href="global.html#ExperimentStatus">ExperimentStatus</a></li><li><a href="global.html#FIREWORKS_MODELS">FIREWORKS_MODELS</a></li><li><a href="global.html#GROQ_MODELS">GROQ_MODELS</a></li><li><a href="global.html#INPUT_TYPES">INPUT_TYPES</a></li><li><a href="global.html#IsolationLevels">IsolationLevels</a></li><li><a href="global.html#MISTRAL_MODELS">MISTRAL_MODELS</a></li><li><a href="global.html#MODEL_CATEGORIES">MODEL_CATEGORIES</a></li><li><a href="global.html#ModelFormat">ModelFormat</a></li><li><a href="global.html#ModelFormats">ModelFormats</a></li><li><a href="global.html#NOVITA_ENDPOINTS">NOVITA_ENDPOINTS</a></li><li><a href="global.html#NOVITA_MODELS">NOVITA_MODELS</a></li><li><a href="global.html#OPENAI_MODELS">OPENAI_MODELS</a></li><li><a href="global.html#PERPLEXITY_MODELS">PERPLEXITY_MODELS</a></li><li><a href="global.html#POPULAR_MODELS">POPULAR_MODELS</a></li><li><a href="global.html#PROVIDER_AUTH_CONFIG">PROVIDER_AUTH_CONFIG</a></li><li><a href="global.html#PROVIDER_CATEGORIES">PROVIDER_CATEGORIES</a></li><li><a href="global.html#PROVIDER_CONFIGS">PROVIDER_CONFIGS</a></li><li><a href="global.html#PROVIDER_FEATURES">PROVIDER_FEATURES</a></li><li><a href="global.html#Permissions">Permissions</a></li><li><a href="global.html#QuantizationMethod">QuantizationMethod</a></li><li><a href="global.html#QuantizationPrecision">QuantizationPrecision</a></li><li><a href="global.html#QuotaTypes">QuotaTypes</a></li><li><a href="global.html#RiskLevels">RiskLevels</a></li><li><a href="global.html#RoutingStrategies">RoutingStrategies</a></li><li><a href="global.html#SAFETY_LEVELS">SAFETY_LEVELS</a></li><li><a href="global.html#SLAMetricTypes">SLAMetricTypes</a></li><li><a href="global.html#SLAStatus">SLAStatus</a></li><li><a href="global.html#SessionTypes">SessionTypes</a></li><li><a href="global.html#SplittingAlgorithms">SplittingAlgorithms</a></li><li><a href="global.html#StatisticalTests">StatisticalTests</a></li><li><a href="global.html#TOGETHER_MODELS">TOGETHER_MODELS</a></li><li><a href="global.html#TimeWindows">TimeWindows</a></li><li><a href="global.html#TokenizerType">TokenizerType</a></li><li><a href="global.html#UserRoles">UserRoles</a></li><li><a href="global.html#VERTEX_AI_MODELS">VERTEX_AI_MODELS</a></li><li><a href="global.html#VERTEX_REGIONS">VERTEX_REGIONS</a></li><li><a href="global.html#ValidationSeverity">ValidationSeverity</a></li><li><a href="global.html#ValidationTestType">ValidationTestType</a></li><li><a href="global.html#adjustTimeouts">adjustTimeouts</a></li><li><a href="global.html#attemptRecovery">attemptRecovery</a></li><li><a href="global.html#checkConnectivity">checkConnectivity</a></li><li><a href="global.html#clearCache">clearCache</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#createAdapter">createAdapter</a></li><li><a href="global.html#createEnterpriseExpressRoutes">createEnterpriseExpressRoutes</a></li><li><a href="global.html#createEnterpriseRouter">createEnterpriseRouter</a></li><li><a href="global.html#createEnterpriseWebSocketHandlers">createEnterpriseWebSocketHandlers</a></li><li><a href="global.html#createMissingResources">createMissingResources</a></li><li><a href="global.html#defaultEnterpriseConfig">defaultEnterpriseConfig</a></li><li><a href="global.html#emergencyShutdown">emergencyShutdown</a></li><li><a href="global.html#enterpriseVersion">enterpriseVersion</a></li><li><a href="global.html#errorMonitoringMiddleware">errorMonitoringMiddleware</a></li><li><a href="global.html#escalateError">escalateError</a></li><li><a href="global.html#executeRecovery">executeRecovery</a></li><li><a href="global.html#getAdapter">getAdapter</a></li><li><a href="global.html#getEnabledFeatures">getEnabledFeatures</a></li><li><a href="global.html#getMonitoringStatus">getMonitoringStatus</a></li><li><a href="global.html#getProviderAuthType">getProviderAuthType</a></li><li><a href="global.html#getProviderInfo">getProviderInfo</a></li><li><a href="global.html#getProvidersByCategory">getProvidersByCategory</a></li><li><a href="global.html#getProvidersByFeature">getProvidersByFeature</a></li><li><a href="global.html#getStats">getStats</a></li><li><a href="global.html#getSupportedProviders">getSupportedProviders</a></li><li><a href="global.html#gracefulShutdown">gracefulShutdown</a></li><li><a href="global.html#handleCriticalError">handleCriticalError</a></li><li><a href="global.html#handleMemoryLeak">handleMemoryLeak</a></li><li><a href="global.html#httpMonitoringMiddleware">httpMonitoringMiddleware</a></li><li><a href="global.html#isFeatureEnabled">isFeatureEnabled</a></li><li><a href="global.html#isProviderSupported">isProviderSupported</a></li><li><a href="global.html#logError">logError</a></li><li><a href="global.html#performHealthCheck">performHealthCheck</a></li><li><a href="global.html#recordCustomMetric">recordCustomMetric</a></li><li><a href="global.html#registerAlertRule">registerAlertRule</a></li><li><a href="global.html#registerDependency">registerDependency</a></li><li><a href="global.html#registerHealthCheck">registerHealthCheck</a></li><li><a href="global.html#reinstallDependencies">reinstallDependencies</a></li><li><a href="global.html#reload">reload</a></li><li><a href="global.html#restartProcess">restartProcess</a></li><li><a href="global.html#retryConnection">retryConnection</a></li><li><a href="global.html#selectRecoveryStrategy">selectRecoveryStrategy</a></li><li><a href="global.html#setupHandlers">setupHandlers</a></li><li><a href="global.html#setupMonitoring">setupMonitoring</a></li><li><a href="global.html#softRestart">softRestart</a></li><li><a href="global.html#startHealthMonitoring">startHealthMonitoring</a></li><li><a href="global.html#startPerformanceProfile">startPerformanceProfile</a></li><li><a href="global.html#validateEnterpriseConfig">validateEnterpriseConfig</a></li><li><a href="global.html#withCacheMonitoring">withCacheMonitoring</a></li><li><a href="global.html#withDatabaseMonitoring">withDatabaseMonitoring</a></li><li><a href="global.html#withModelMonitoring">withModelMonitoring</a></li><li><a href="global.html#withQueueMonitoring">withQueueMonitoring</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Aug 20 2025 19:41:21 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
