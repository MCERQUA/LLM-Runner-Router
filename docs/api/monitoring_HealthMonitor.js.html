<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: monitoring/HealthMonitor.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: monitoring/HealthMonitor.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * 🏥 Health Monitor - System Vitals Observatory
 * Comprehensive health checks and dependency monitoring
 * Echo AI Systems - Keeping the pulse of the system
 */

import EventEmitter from 'events';
import os from 'os';
import process from 'process';
import { promises as fs } from 'fs';
import Logger from '../utils/Logger.js';

class HealthMonitor extends EventEmitter {
  constructor(config = {}) {
    super();
    this.logger = new Logger('HealthMonitor');
    this.config = {
      interval: config.interval || 10000, // 10 seconds
      timeout: config.timeout || 5000, // 5 seconds
      retries: config.retries || 3,
      thresholds: {
        cpu: config.thresholds?.cpu || 80, // 80%
        memory: config.thresholds?.memory || 85, // 85%
        disk: config.thresholds?.disk || 90, // 90%
        errorRate: config.thresholds?.errorRate || 0.05, // 5%
        responseTime: config.thresholds?.responseTime || 5000, // 5 seconds
        ...config.thresholds,
      },
      dependencies: config.dependencies || [],
      ...config,
    };

    this.isRunning = false;
    this.intervalId = null;
    this.healthStatus = {
      status: 'unknown',
      timestamp: new Date(),
      uptime: 0,
      checks: new Map(),
      dependencies: new Map(),
      metrics: {},
    };

    this.checks = new Map();
    this.dependencies = new Map();
    this.errorCounts = new Map();
    this.responseTimeHistory = [];
    
    this._registerDefaultChecks();
  }

  /**
   * Register default health checks
   */
  _registerDefaultChecks() {
    // System resource checks
    this.registerCheck('cpu_usage', this._checkCpuUsage.bind(this));
    this.registerCheck('memory_usage', this._checkMemoryUsage.bind(this));
    this.registerCheck('disk_usage', this._checkDiskUsage.bind(this));
    this.registerCheck('process_health', this._checkProcessHealth.bind(this));
    this.registerCheck('error_rate', this._checkErrorRate.bind(this));
    this.registerCheck('response_time', this._checkResponseTime.bind(this));
    
    // Network checks
    this.registerCheck('network_connectivity', this._checkNetworkConnectivity.bind(this));
    
    this.logger.info('Default health checks registered');
  }

  /**
   * Register a custom health check
   */
  registerCheck(name, checkFunction, options = {}) {
    this.checks.set(name, {
      function: checkFunction,
      enabled: options.enabled ?? true,
      interval: options.interval || this.config.interval,
      timeout: options.timeout || this.config.timeout,
      retries: options.retries || this.config.retries,
      ...options,
    });
    
    this.logger.info(`Health check registered: ${name}`);
  }

  /**
   * Register a dependency for monitoring
   */
  registerDependency(name, checkFunction, options = {}) {
    this.dependencies.set(name, {
      function: checkFunction,
      enabled: options.enabled ?? true,
      critical: options.critical ?? false,
      timeout: options.timeout || this.config.timeout,
      retries: options.retries || this.config.retries,
      ...options,
    });
    
    this.logger.info(`Dependency registered: ${name} (critical: ${options.critical})`);
  }

  /**
   * Start health monitoring
   */
  start() {
    if (this.isRunning) {
      this.logger.warn('Health monitor already running');
      return;
    }

    this.isRunning = true;
    this.logger.info(`Starting health monitor (interval: ${this.config.interval}ms)`);
    
    // Run initial check
    this._runHealthChecks();
    
    // Schedule periodic checks
    this.intervalId = setInterval(() => {
      this._runHealthChecks();
    }, this.config.interval);

    this.emit('started');
  }

  /**
   * Stop health monitoring
   */
  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
    
    this.isRunning = false;
    this.logger.info('Health monitor stopped');
    this.emit('stopped');
  }

  /**
   * Run all health checks
   */
  async _runHealthChecks() {
    const startTime = Date.now();
    const results = new Map();
    
    this.healthStatus.timestamp = new Date();
    this.healthStatus.uptime = process.uptime();
    
    // Run system checks
    for (const [name, check] of this.checks) {
      if (!check.enabled) continue;
      
      try {
        const result = await this._executeCheckWithTimeout(name, check);
        results.set(name, result);
        this.healthStatus.checks.set(name, result);
      } catch (error) {
        const errorResult = {
          status: 'error',
          message: error.message,
          timestamp: new Date(),
        };
        results.set(name, errorResult);
        this.healthStatus.checks.set(name, errorResult);
        this.logger.error(`Health check failed: ${name}`, error);
      }
    }
    
    // Run dependency checks
    for (const [name, dependency] of this.dependencies) {
      if (!dependency.enabled) continue;
      
      try {
        const result = await this._executeDependencyCheck(name, dependency);
        this.healthStatus.dependencies.set(name, result);
      } catch (error) {
        const errorResult = {
          status: 'error',
          message: error.message,
          timestamp: new Date(),
          critical: dependency.critical,
        };
        this.healthStatus.dependencies.set(name, errorResult);
        this.logger.error(`Dependency check failed: ${name}`, error);
      }
    }
    
    // Calculate overall health status
    this._updateOverallStatus();
    
    // Update metrics
    this._updateMetrics();
    
    const duration = Date.now() - startTime;
    this.logger.debug(`Health checks completed in ${duration}ms`);
    
    // Emit health status
    this.emit('health-check', this.healthStatus);
    
    // Emit specific events for status changes
    if (this.healthStatus.status === 'unhealthy') {
      this.emit('unhealthy', this.healthStatus);
    } else if (this.healthStatus.status === 'degraded') {
      this.emit('degraded', this.healthStatus);
    }
  }

  /**
   * Execute a health check with timeout and retries
   */
  async _executeCheckWithTimeout(name, check) {
    let lastError = null;
    
    for (let attempt = 1; attempt &lt;= check.retries; attempt++) {
      try {
        const result = await Promise.race([
          check.function(),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Check timeout')), check.timeout)
          ),
        ]);
        
        return {
          status: result.status || 'healthy',
          message: result.message || 'OK',
          data: result.data || {},
          timestamp: new Date(),
          attempt,
        };
      } catch (error) {
        lastError = error;
        if (attempt &lt; check.retries) {
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
      }
    }
    
    throw lastError;
  }

  /**
   * Execute a dependency check
   */
  async _executeDependencyCheck(name, dependency) {
    return this._executeCheckWithTimeout(name, dependency);
  }

  /**
   * CPU usage check
   */
  async _checkCpuUsage() {
    const cpus = os.cpus();
    const loadAvg = os.loadavg();
    const usage = Math.min(100, (loadAvg[0] / cpus.length) * 100);
    
    return {
      status: usage > this.config.thresholds.cpu ? 'unhealthy' : 'healthy',
      message: `CPU usage: ${usage.toFixed(1)}%`,
      data: {
        usage: usage,
        threshold: this.config.thresholds.cpu,
        loadAverage: loadAvg,
        cpuCount: cpus.length,
      },
    };
  }

  /**
   * Memory usage check
   */
  async _checkMemoryUsage() {
    const totalMem = os.totalmem();
    const freeMem = os.freemem();
    const usedMem = totalMem - freeMem;
    const usage = (usedMem / totalMem) * 100;
    
    const processMemory = process.memoryUsage();
    
    return {
      status: usage > this.config.thresholds.memory ? 'unhealthy' : 'healthy',
      message: `Memory usage: ${usage.toFixed(1)}%`,
      data: {
        usage: usage,
        threshold: this.config.thresholds.memory,
        total: totalMem,
        used: usedMem,
        free: freeMem,
        process: processMemory,
      },
    };
  }

  /**
   * Disk usage check
   */
  async _checkDiskUsage() {
    try {
      const stats = await fs.stat(process.cwd());
      // Simplified disk check - in production, use statvfs or similar
      return {
        status: 'healthy',
        message: 'Disk accessible',
        data: {
          accessible: true,
          path: process.cwd(),
        },
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        message: 'Disk not accessible',
        data: {
          accessible: false,
          error: error.message,
        },
      };
    }
  }

  /**
   * Process health check
   */
  async _checkProcessHealth() {
    const memUsage = process.memoryUsage();
    const heapUsed = (memUsage.heapUsed / memUsage.heapTotal) * 100;
    
    return {
      status: heapUsed > 90 ? 'unhealthy' : 'healthy',
      message: `Process healthy, heap usage: ${heapUsed.toFixed(1)}%`,
      data: {
        pid: process.pid,
        uptime: process.uptime(),
        memory: memUsage,
        heapUsage: heapUsed,
      },
    };
  }

  /**
   * Error rate check
   */
  async _checkErrorRate() {
    const totalErrors = Array.from(this.errorCounts.values()).reduce((sum, count) => sum + count, 0);
    const timeWindow = 60; // 1 minute
    const errorRate = totalErrors / timeWindow;
    
    return {
      status: errorRate > this.config.thresholds.errorRate ? 'unhealthy' : 'healthy',
      message: `Error rate: ${errorRate.toFixed(3)}/sec`,
      data: {
        errorRate,
        threshold: this.config.thresholds.errorRate,
        totalErrors,
        timeWindow,
      },
    };
  }

  /**
   * Response time check
   */
  async _checkResponseTime() {
    const recentTimes = this.responseTimeHistory.slice(-100); // Last 100 requests
    const avgResponseTime = recentTimes.length > 0 
      ? recentTimes.reduce((sum, time) => sum + time, 0) / recentTimes.length 
      : 0;
    
    return {
      status: avgResponseTime > this.config.thresholds.responseTime ? 'unhealthy' : 'healthy',
      message: `Avg response time: ${avgResponseTime.toFixed(1)}ms`,
      data: {
        averageResponseTime: avgResponseTime,
        threshold: this.config.thresholds.responseTime,
        sampleSize: recentTimes.length,
      },
    };
  }

  /**
   * Network connectivity check
   */
  async _checkNetworkConnectivity() {
    // Simple connectivity check - can be enhanced with actual network tests
    return {
      status: 'healthy',
      message: 'Network connectivity OK',
      data: {
        hostname: os.hostname(),
        networkInterfaces: Object.keys(os.networkInterfaces()),
      },
    };
  }

  /**
   * Update overall health status
   */
  _updateOverallStatus() {
    const checkStatuses = Array.from(this.healthStatus.checks.values()).map(check => check.status);
    const dependencyStatuses = Array.from(this.healthStatus.dependencies.values());
    
    // Check for critical dependency failures
    const criticalFailures = dependencyStatuses.filter(dep => dep.critical &amp;&amp; dep.status === 'error');
    if (criticalFailures.length > 0) {
      this.healthStatus.status = 'unhealthy';
      return;
    }
    
    // Check overall status
    const unhealthyChecks = checkStatuses.filter(status => status === 'unhealthy' || status === 'error');
    const degradedChecks = checkStatuses.filter(status => status === 'degraded' || status === 'warning');
    
    if (unhealthyChecks.length > 0) {
      this.healthStatus.status = 'unhealthy';
    } else if (degradedChecks.length > 0) {
      this.healthStatus.status = 'degraded';
    } else {
      this.healthStatus.status = 'healthy';
    }
  }

  /**
   * Update metrics
   */
  _updateMetrics() {
    this.healthStatus.metrics = {
      checksTotal: this.checks.size,
      checksEnabled: Array.from(this.checks.values()).filter(check => check.enabled).length,
      dependenciesTotal: this.dependencies.size,
      dependenciesEnabled: Array.from(this.dependencies.values()).filter(dep => dep.enabled).length,
      lastCheckDuration: Date.now() - this.healthStatus.timestamp.getTime(),
      uptime: process.uptime(),
    };
  }

  /**
   * Record an error for error rate calculation
   */
  recordError(type = 'general') {
    const current = this.errorCounts.get(type) || 0;
    this.errorCounts.set(type, current + 1);
    
    // Clean up old error counts periodically
    setTimeout(() => {
      const count = this.errorCounts.get(type) || 0;
      if (count > 0) {
        this.errorCounts.set(type, count - 1);
      }
    }, 60000); // Remove after 1 minute
  }

  /**
   * Record response time
   */
  recordResponseTime(time) {
    this.responseTimeHistory.push(time);
    
    // Keep only recent history
    if (this.responseTimeHistory.length > 1000) {
      this.responseTimeHistory = this.responseTimeHistory.slice(-500);
    }
  }

  /**
   * Get current health status
   */
  getHealthStatus() {
    return {
      ...this.healthStatus,
      checks: Object.fromEntries(this.healthStatus.checks),
      dependencies: Object.fromEntries(this.healthStatus.dependencies),
    };
  }

  /**
   * Get health summary
   */
  getHealthSummary() {
    const status = this.getHealthStatus();
    const checksHealthy = Object.values(status.checks).filter(check => check.status === 'healthy').length;
    const depsHealthy = Object.values(status.dependencies).filter(dep => dep.status === 'healthy').length;
    
    return {
      status: status.status,
      uptime: status.uptime,
      timestamp: status.timestamp,
      summary: {
        checks: {
          total: Object.keys(status.checks).length,
          healthy: checksHealthy,
          unhealthy: Object.keys(status.checks).length - checksHealthy,
        },
        dependencies: {
          total: Object.keys(status.dependencies).length,
          healthy: depsHealthy,
          unhealthy: Object.keys(status.dependencies).length - depsHealthy,
        },
      },
    };
  }

  /**
   * Force run health checks (useful for testing)
   */
  async runChecks() {
    await this._runHealthChecks();
    return this.getHealthStatus();
  }
}

// Export singleton instance
const healthMonitor = new HealthMonitor();

export default healthMonitor;
export { HealthMonitor };</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ABTestingManager.html">ABTestingManager</a></li><li><a href="APILoader.html">APILoader</a></li><li><a href="AnthropicAdapter.html">AnthropicAdapter</a></li><li><a href="AuditLogger.html">AuditLogger</a></li><li><a href="AuthManager.html">AuthManager</a></li><li><a href="AuthMiddleware.html">AuthMiddleware</a></li><li><a href="AzureOpenAIAdapter.html">AzureOpenAIAdapter</a></li><li><a href="BPETokenizer.html">BPETokenizer</a></li><li><a href="BaseEngine.html">BaseEngine</a></li><li><a href="BaseLoader.html">BaseLoader</a></li><li><a href="BedrockAdapter.html">BedrockAdapter</a></li><li><a href="BinaryLoader.html">BinaryLoader</a></li><li><a href="BinaryModel.html">BinaryModel</a></li><li><a href="BitNetLoader.html">BitNetLoader</a></li><li><a href="CohereAdapter.html">CohereAdapter</a></li><li><a href="ConversionConfig.html">ConversionConfig</a></li><li><a href="ConversionResult.html">ConversionResult</a></li><li><a href="DeepSeekAdapter.html">DeepSeekAdapter</a></li><li><a href="EnterpriseAuthManager.html">EnterpriseAuthManager</a></li><li><a href="EnterpriseManager.html">EnterpriseManager</a></li><li><a href="EnterpriseRouter.html">EnterpriseRouter</a></li><li><a href="ErrorHandler.html">ErrorHandler</a></li><li><a href="FireworksAdapter.html">FireworksAdapter</a></li><li><a href="FormatConverter.html">FormatConverter</a></li><li><a href="GGUFLoader.html">GGUFLoader</a></li><li><a href="GGUFModel.html">GGUFModel</a></li><li><a href="GRPCClient.html">GRPCClient</a></li><li><a href="GroqAdapter.html">GroqAdapter</a></li><li><a href="LLMRouter.html">LLMRouter</a></li><li><a href="MistralAdapter.html">MistralAdapter</a></li><li><a href="MockLoader.html">MockLoader</a></li><li><a href="MockModel.html">MockModel</a></li><li><a href="ModelError.html">ModelError</a></li><li><a href="ModelInterface.html">ModelInterface</a></li><li><a href="ModelQuantizer.html">ModelQuantizer</a></li><li><a href="ModelRegistry.html">ModelRegistry</a></li><li><a href="ModelTemplates.html">ModelTemplates</a></li><li><a href="MultiTenancyManager.html">MultiTenancyManager</a></li><li><a href="NovitaAdapter.html">NovitaAdapter</a></li><li><a href="OpenAIAdapter.html">OpenAIAdapter</a></li><li><a href="OpenRouterAdapter.html">OpenRouterAdapter</a></li><li><a href="PerplexityAdapter.html">PerplexityAdapter</a></li><li><a href="Pipeline.html">Pipeline</a></li><li><a href="PyTorchLoader.html">PyTorchLoader</a></li><li><a href="PyTorchModel.html">PyTorchModel</a></li><li><a href="QuantizationConfig.html">QuantizationConfig</a></li><li><a href="QuantizationResult.html">QuantizationResult</a></li><li><a href="Router.html">Router</a></li><li><a href="SLAMonitor.html">SLAMonitor</a></li><li><a href="SentencePieceTokenizer.html">SentencePieceTokenizer</a></li><li><a href="SimpleLoader.html">SimpleLoader</a></li><li><a href="SimpleModel.html">SimpleModel</a></li><li><a href="TogetherAdapter.html">TogetherAdapter</a></li><li><a href="TokenizationResult.html">TokenizationResult</a></li><li><a href="TokenizerConfig.html">TokenizerConfig</a></li><li><a href="UniversalTokenizer.html">UniversalTokenizer</a></li><li><a href="ValidationConfig.html">ValidationConfig</a></li><li><a href="ValidationSuite.html">ValidationSuite</a></li><li><a href="ValidationSuiteResult.html">ValidationSuiteResult</a></li><li><a href="ValidationTestResult.html">ValidationTestResult</a></li><li><a href="VertexAIAdapter.html">VertexAIAdapter</a></li><li><a href="WordPieceTokenizer.html">WordPieceTokenizer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ADAPTER_REGISTRY">ADAPTER_REGISTRY</a></li><li><a href="global.html#API_KEY_PATTERNS">API_KEY_PATTERNS</a></li><li><a href="global.html#AUTH_TYPES">AUTH_TYPES</a></li><li><a href="global.html#AZURE_API_VERSIONS">AZURE_API_VERSIONS</a></li><li><a href="global.html#AZURE_OPENAI_MODELS">AZURE_OPENAI_MODELS</a></li><li><a href="global.html#Architectures">Architectures</a></li><li><a href="global.html#AuditEventTypes">AuditEventTypes</a></li><li><a href="global.html#AuthMethods">AuthMethods</a></li><li><a href="global.html#BEDROCK_MODELS">BEDROCK_MODELS</a></li><li><a href="global.html#BreachSeverity">BreachSeverity</a></li><li><a href="global.html#CLAUDE_MODELS">CLAUDE_MODELS</a></li><li><a href="global.html#COHERE_MODELS">COHERE_MODELS</a></li><li><a href="global.html#COMPLIANCE_FEATURES">COMPLIANCE_FEATURES</a></li><li><a href="global.html#Capabilities">Capabilities</a></li><li><a href="global.html#ComplianceFrameworks">ComplianceFrameworks</a></li><li><a href="global.html#DEEPSEEK_ENDPOINTS">DEEPSEEK_ENDPOINTS</a></li><li><a href="global.html#DEEPSEEK_MODELS">DEEPSEEK_MODELS</a></li><li><a href="global.html#EnterpriseFeatures">EnterpriseFeatures</a></li><li><a href="global.html#ExperimentStatus">ExperimentStatus</a></li><li><a href="global.html#FIREWORKS_MODELS">FIREWORKS_MODELS</a></li><li><a href="global.html#GROQ_MODELS">GROQ_MODELS</a></li><li><a href="global.html#INPUT_TYPES">INPUT_TYPES</a></li><li><a href="global.html#IsolationLevels">IsolationLevels</a></li><li><a href="global.html#MISTRAL_MODELS">MISTRAL_MODELS</a></li><li><a href="global.html#MODEL_CATEGORIES">MODEL_CATEGORIES</a></li><li><a href="global.html#ModelFormat">ModelFormat</a></li><li><a href="global.html#ModelFormats">ModelFormats</a></li><li><a href="global.html#NOVITA_ENDPOINTS">NOVITA_ENDPOINTS</a></li><li><a href="global.html#NOVITA_MODELS">NOVITA_MODELS</a></li><li><a href="global.html#OPENAI_MODELS">OPENAI_MODELS</a></li><li><a href="global.html#PERPLEXITY_MODELS">PERPLEXITY_MODELS</a></li><li><a href="global.html#POPULAR_MODELS">POPULAR_MODELS</a></li><li><a href="global.html#PROVIDER_AUTH_CONFIG">PROVIDER_AUTH_CONFIG</a></li><li><a href="global.html#PROVIDER_CATEGORIES">PROVIDER_CATEGORIES</a></li><li><a href="global.html#PROVIDER_CONFIGS">PROVIDER_CONFIGS</a></li><li><a href="global.html#PROVIDER_FEATURES">PROVIDER_FEATURES</a></li><li><a href="global.html#Permissions">Permissions</a></li><li><a href="global.html#QuantizationMethod">QuantizationMethod</a></li><li><a href="global.html#QuantizationPrecision">QuantizationPrecision</a></li><li><a href="global.html#QuotaTypes">QuotaTypes</a></li><li><a href="global.html#RiskLevels">RiskLevels</a></li><li><a href="global.html#RoutingStrategies">RoutingStrategies</a></li><li><a href="global.html#SAFETY_LEVELS">SAFETY_LEVELS</a></li><li><a href="global.html#SLAMetricTypes">SLAMetricTypes</a></li><li><a href="global.html#SLAStatus">SLAStatus</a></li><li><a href="global.html#SessionTypes">SessionTypes</a></li><li><a href="global.html#SplittingAlgorithms">SplittingAlgorithms</a></li><li><a href="global.html#StatisticalTests">StatisticalTests</a></li><li><a href="global.html#TOGETHER_MODELS">TOGETHER_MODELS</a></li><li><a href="global.html#TimeWindows">TimeWindows</a></li><li><a href="global.html#TokenizerType">TokenizerType</a></li><li><a href="global.html#UserRoles">UserRoles</a></li><li><a href="global.html#VERTEX_AI_MODELS">VERTEX_AI_MODELS</a></li><li><a href="global.html#VERTEX_REGIONS">VERTEX_REGIONS</a></li><li><a href="global.html#ValidationSeverity">ValidationSeverity</a></li><li><a href="global.html#ValidationTestType">ValidationTestType</a></li><li><a href="global.html#adjustTimeouts">adjustTimeouts</a></li><li><a href="global.html#attemptRecovery">attemptRecovery</a></li><li><a href="global.html#checkConnectivity">checkConnectivity</a></li><li><a href="global.html#clearCache">clearCache</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#createAdapter">createAdapter</a></li><li><a href="global.html#createEnterpriseExpressRoutes">createEnterpriseExpressRoutes</a></li><li><a href="global.html#createEnterpriseRouter">createEnterpriseRouter</a></li><li><a href="global.html#createEnterpriseWebSocketHandlers">createEnterpriseWebSocketHandlers</a></li><li><a href="global.html#createMissingResources">createMissingResources</a></li><li><a href="global.html#defaultEnterpriseConfig">defaultEnterpriseConfig</a></li><li><a href="global.html#emergencyShutdown">emergencyShutdown</a></li><li><a href="global.html#enterpriseVersion">enterpriseVersion</a></li><li><a href="global.html#errorMonitoringMiddleware">errorMonitoringMiddleware</a></li><li><a href="global.html#escalateError">escalateError</a></li><li><a href="global.html#executeRecovery">executeRecovery</a></li><li><a href="global.html#getAdapter">getAdapter</a></li><li><a href="global.html#getEnabledFeatures">getEnabledFeatures</a></li><li><a href="global.html#getMonitoringStatus">getMonitoringStatus</a></li><li><a href="global.html#getProviderAuthType">getProviderAuthType</a></li><li><a href="global.html#getProviderInfo">getProviderInfo</a></li><li><a href="global.html#getProvidersByCategory">getProvidersByCategory</a></li><li><a href="global.html#getProvidersByFeature">getProvidersByFeature</a></li><li><a href="global.html#getStats">getStats</a></li><li><a href="global.html#getSupportedProviders">getSupportedProviders</a></li><li><a href="global.html#gracefulShutdown">gracefulShutdown</a></li><li><a href="global.html#handleCriticalError">handleCriticalError</a></li><li><a href="global.html#handleMemoryLeak">handleMemoryLeak</a></li><li><a href="global.html#httpMonitoringMiddleware">httpMonitoringMiddleware</a></li><li><a href="global.html#isFeatureEnabled">isFeatureEnabled</a></li><li><a href="global.html#isProviderSupported">isProviderSupported</a></li><li><a href="global.html#logError">logError</a></li><li><a href="global.html#performHealthCheck">performHealthCheck</a></li><li><a href="global.html#recordCustomMetric">recordCustomMetric</a></li><li><a href="global.html#registerAlertRule">registerAlertRule</a></li><li><a href="global.html#registerDependency">registerDependency</a></li><li><a href="global.html#registerHealthCheck">registerHealthCheck</a></li><li><a href="global.html#reinstallDependencies">reinstallDependencies</a></li><li><a href="global.html#reload">reload</a></li><li><a href="global.html#restartProcess">restartProcess</a></li><li><a href="global.html#retryConnection">retryConnection</a></li><li><a href="global.html#selectRecoveryStrategy">selectRecoveryStrategy</a></li><li><a href="global.html#setupHandlers">setupHandlers</a></li><li><a href="global.html#setupMonitoring">setupMonitoring</a></li><li><a href="global.html#softRestart">softRestart</a></li><li><a href="global.html#startHealthMonitoring">startHealthMonitoring</a></li><li><a href="global.html#startPerformanceProfile">startPerformanceProfile</a></li><li><a href="global.html#validateEnterpriseConfig">validateEnterpriseConfig</a></li><li><a href="global.html#withCacheMonitoring">withCacheMonitoring</a></li><li><a href="global.html#withDatabaseMonitoring">withDatabaseMonitoring</a></li><li><a href="global.html#withModelMonitoring">withModelMonitoring</a></li><li><a href="global.html#withQueueMonitoring">withQueueMonitoring</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Aug 20 2025 19:41:21 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
