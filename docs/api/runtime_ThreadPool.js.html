<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: runtime/ThreadPool.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: runtime/ThreadPool.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Thread Pool Manager
 * Manages worker threads for parallel processing
 * Provides efficient task distribution and resource management
 */

import { Worker, isMainThread, parentPort, workerData } from 'worker_threads';
import { EventEmitter } from 'events';
import { cpus } from 'os';
import { Logger } from '../utils/Logger.js';
import PQueue from 'p-queue';

class ThreadPool extends EventEmitter {
  constructor(config = {}) {
    super();
    this.logger = new Logger('ThreadPool');
    this.config = {
      minThreads: config.minThreads || 2,
      maxThreads: config.maxThreads || cpus().length,
      idleTimeout: config.idleTimeout || 60000, // 1 minute
      taskTimeout: config.taskTimeout || 30000, // 30 seconds
      maxQueueSize: config.maxQueueSize || 1000,
      workerScript: config.workerScript || null,
      resourceLimits: config.resourceLimits || {
        maxOldGenerationSizeMb: 512,
        maxYoungGenerationSizeMb: 128,
        codeRangeSizeMb: 64
      },
      enableStatistics: config.enableStatistics !== false,
      autoScale: config.autoScale !== false
    };
    
    this.workers = new Map();
    this.taskQueue = new PQueue({ 
      concurrency: this.config.maxThreads,
      timeout: this.config.taskTimeout
    });
    this.statistics = {
      tasksCompleted: 0,
      tasksFailed: 0,
      totalExecutionTime: 0,
      averageExecutionTime: 0,
      threadsCreated: 0,
      threadsDestroyed: 0,
      currentThreads: 0
    };
    
    this.initialized = false;
    this.shuttingDown = false;
  }

  /**
   * Initialize thread pool
   */
  async initialize() {
    if (this.initialized) return true;
    
    try {
      this.logger.info('Initializing Thread Pool');
      
      // Create initial worker threads
      await this.createInitialWorkers();
      
      // Setup auto-scaling if enabled
      if (this.config.autoScale) {
        this.setupAutoScaling();
      }
      
      // Setup statistics collection
      if (this.config.enableStatistics) {
        this.setupStatisticsCollection();
      }
      
      this.initialized = true;
      this.logger.info(`Thread Pool initialized with ${this.workers.size} workers`);
      
      return true;
    } catch (error) {
      this.logger.error(`Initialization failed: ${error.message}`);
      return false;
    }
  }

  /**
   * Create initial worker threads
   */
  async createInitialWorkers() {
    const promises = [];
    
    for (let i = 0; i &lt; this.config.minThreads; i++) {
      promises.push(this.createWorker());
    }
    
    await Promise.all(promises);
  }

  /**
   * Create a new worker thread
   */
  async createWorker() {
    return new Promise((resolve, reject) => {
      const workerId = `worker-${Date.now()}-${Math.random()}`;
      
      let worker;
      
      if (this.config.workerScript) {
        // Use provided worker script
        worker = new Worker(this.config.workerScript, {
          workerData: { workerId },
          resourceLimits: this.config.resourceLimits
        });
      } else {
        // Create inline worker
        const workerCode = this.getInlineWorkerCode();
        worker = new Worker(workerCode, {
          eval: true,
          workerData: { workerId },
          resourceLimits: this.config.resourceLimits
        });
      }
      
      const workerInfo = {
        id: workerId,
        worker,
        busy: false,
        tasksCompleted: 0,
        lastUsed: Date.now(),
        created: Date.now()
      };
      
      // Setup event handlers
      worker.on('message', (message) => this.handleWorkerMessage(workerInfo, message));
      worker.on('error', (error) => this.handleWorkerError(workerInfo, error));
      worker.on('exit', (code) => this.handleWorkerExit(workerInfo, code));
      
      worker.once('online', () => {
        this.workers.set(workerId, workerInfo);
        this.statistics.threadsCreated++;
        this.statistics.currentThreads++;
        this.emit('workerCreated', workerId);
        resolve(workerInfo);
      });
      
      // Timeout for worker creation
      setTimeout(() => {
        if (!this.workers.has(workerId)) {
          worker.terminate();
          reject(new Error('Worker creation timeout'));
        }
      }, 5000);
    });
  }

  /**
   * Get inline worker code
   */
  getInlineWorkerCode() {
    return `
      const { parentPort, workerData } = require('worker_threads');
      const { performance } = require('perf_hooks');
      
      const workerId = workerData.workerId;
      const tasks = new Map();
      
      // Message handler
      parentPort.on('message', async (message) => {
        const { type, taskId, data } = message;
        
        try {
          const startTime = performance.now();
          let result;
          
          switch (type) {
            case 'execute':
              result = await executeTask(data);
              break;
              
            case 'compute':
              result = await performComputation(data);
              break;
              
            case 'transform':
              result = await performTransformation(data);
              break;
              
            case 'process':
              result = await processData(data);
              break;
              
            case 'ping':
              result = { pong: true };
              break;
              
            default:
              throw new Error('Unknown task type: ' + type);
          }
          
          const duration = performance.now() - startTime;
          
          parentPort.postMessage({
            type: 'result',
            taskId,
            result,
            duration,
            workerId
          });
        } catch (error) {
          parentPort.postMessage({
            type: 'error',
            taskId,
            error: error.message,
            stack: error.stack,
            workerId
          });
        }
      });
      
      // Execute generic task
      async function executeTask(data) {
        const { operation, input } = data;
        
        switch (operation) {
          case 'factorial':
            return factorial(input);
          case 'fibonacci':
            return fibonacci(input);
          case 'prime':
            return isPrime(input);
          case 'sort':
            return quickSort(input);
          default:
            return input;
        }
      }
      
      // Perform computation
      async function performComputation(data) {
        const { type, input } = data;
        
        switch (type) {
          case 'matmul':
            return matrixMultiply(input.a, input.b);
          case 'fft':
            return fastFourierTransform(input);
          case 'convolution':
            return convolution(input.signal, input.kernel);
          default:
            return input;
        }
      }
      
      // Perform transformation
      async function performTransformation(data) {
        const { tensor, operation } = data;
        
        switch (operation) {
          case 'transpose':
            return transpose(tensor);
          case 'reshape':
            return reshape(tensor, data.shape);
          case 'normalize':
            return normalize(tensor);
          default:
            return tensor;
        }
      }
      
      // Process data
      async function processData(data) {
        const { input, pipeline } = data;
        let result = input;
        
        for (const step of pipeline || []) {
          switch (step.type) {
            case 'map':
              result = result.map(step.fn);
              break;
            case 'filter':
              result = result.filter(step.fn);
              break;
            case 'reduce':
              result = result.reduce(step.fn, step.initial);
              break;
            default:
              break;
          }
        }
        
        return result;
      }
      
      // Helper functions
      function factorial(n) {
        if (n &lt;= 1) return 1;
        return n * factorial(n - 1);
      }
      
      function fibonacci(n) {
        if (n &lt;= 1) return n;
        let a = 0, b = 1;
        for (let i = 2; i &lt;= n; i++) {
          [a, b] = [b, a + b];
        }
        return b;
      }
      
      function isPrime(n) {
        if (n &lt;= 1) return false;
        for (let i = 2; i &lt;= Math.sqrt(n); i++) {
          if (n % i === 0) return false;
        }
        return true;
      }
      
      function quickSort(arr) {
        if (arr.length &lt;= 1) return arr;
        const pivot = arr[Math.floor(arr.length / 2)];
        const left = arr.filter(x => x &lt; pivot);
        const middle = arr.filter(x => x === pivot);
        const right = arr.filter(x => x > pivot);
        return [...quickSort(left), ...middle, ...quickSort(right)];
      }
      
      function matrixMultiply(a, b) {
        const result = [];
        for (let i = 0; i &lt; a.length; i++) {
          result[i] = [];
          for (let j = 0; j &lt; b[0].length; j++) {
            let sum = 0;
            for (let k = 0; k &lt; b.length; k++) {
              sum += a[i][k] * b[k][j];
            }
            result[i][j] = sum;
          }
        }
        return result;
      }
      
      function fastFourierTransform(signal) {
        // Simplified FFT (Cooley-Tukey algorithm)
        const N = signal.length;
        if (N &lt;= 1) return signal;
        
        const even = fastFourierTransform(signal.filter((_, i) => i % 2 === 0));
        const odd = fastFourierTransform(signal.filter((_, i) => i % 2 === 1));
        
        const result = new Array(N);
        for (let k = 0; k &lt; N / 2; k++) {
          const t = odd[k] * Math.exp(-2 * Math.PI * k / N);
          result[k] = even[k] + t;
          result[k + N / 2] = even[k] - t;
        }
        return result;
      }
      
      function convolution(signal, kernel) {
        const result = [];
        for (let i = 0; i &lt; signal.length; i++) {
          let sum = 0;
          for (let j = 0; j &lt; kernel.length; j++) {
            if (i - j >= 0) {
              sum += signal[i - j] * kernel[j];
            }
          }
          result.push(sum);
        }
        return result;
      }
      
      function transpose(matrix) {
        return matrix[0].map((_, i) => matrix.map(row => row[i]));
      }
      
      function reshape(tensor, shape) {
        const flat = tensor.flat();
        const result = [];
        let index = 0;
        
        function buildShape(dims) {
          if (dims.length === 1) {
            return flat.slice(index, index += dims[0]);
          }
          const arr = [];
          for (let i = 0; i &lt; dims[0]; i++) {
            arr.push(buildShape(dims.slice(1)));
          }
          return arr;
        }
        
        return buildShape(shape);
      }
      
      function normalize(tensor) {
        const flat = tensor.flat();
        const mean = flat.reduce((a, b) => a + b, 0) / flat.length;
        const std = Math.sqrt(flat.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / flat.length);
        return flat.map(v => (v - mean) / (std + 1e-7));
      }
      
      // Signal ready
      parentPort.postMessage({ type: 'ready', workerId });
    `;
  }

  /**
   * Handle worker message
   */
  handleWorkerMessage(workerInfo, message) {
    const { type, taskId, result, error, duration } = message;
    
    if (type === 'ready') {
      this.logger.debug(`Worker ${workerInfo.id} ready`);
      return;
    }
    
    // Mark worker as available
    workerInfo.busy = false;
    workerInfo.lastUsed = Date.now();
    
    if (type === 'result') {
      workerInfo.tasksCompleted++;
      this.statistics.tasksCompleted++;
      this.statistics.totalExecutionTime += duration || 0;
      this.statistics.averageExecutionTime = 
        this.statistics.totalExecutionTime / this.statistics.tasksCompleted;
      
      this.emit('taskCompleted', { taskId, result, workerId: workerInfo.id });
    } else if (type === 'error') {
      this.statistics.tasksFailed++;
      this.emit('taskFailed', { taskId, error, workerId: workerInfo.id });
    }
  }

  /**
   * Handle worker error
   */
  handleWorkerError(workerInfo, error) {
    this.logger.error(`Worker ${workerInfo.id} error: ${error.message}`);
    this.emit('workerError', { workerId: workerInfo.id, error });
    
    // Restart worker
    this.restartWorker(workerInfo.id);
  }

  /**
   * Handle worker exit
   */
  handleWorkerExit(workerInfo, code) {
    this.logger.info(`Worker ${workerInfo.id} exited with code ${code}`);
    
    this.workers.delete(workerInfo.id);
    this.statistics.threadsDestroyed++;
    this.statistics.currentThreads--;
    
    this.emit('workerExit', { workerId: workerInfo.id, code });
    
    // Create replacement worker if not shutting down
    if (!this.shuttingDown &amp;&amp; this.workers.size &lt; this.config.minThreads) {
      this.createWorker();
    }
  }

  /**
   * Restart a worker
   */
  async restartWorker(workerId) {
    const workerInfo = this.workers.get(workerId);
    if (!workerInfo) return;
    
    try {
      // Terminate old worker
      await workerInfo.worker.terminate();
      this.workers.delete(workerId);
      
      // Create new worker
      await this.createWorker();
    } catch (error) {
      this.logger.error(`Failed to restart worker: ${error.message}`);
    }
  }

  /**
   * Execute task in thread pool
   */
  async execute(type, data) {
    if (!this.initialized) {
      await this.initialize();
    }
    
    if (this.taskQueue.size >= this.config.maxQueueSize) {
      throw new Error('Task queue full');
    }
    
    return this.taskQueue.add(() => this.runTask(type, data));
  }

  /**
   * Run task on available worker
   */
  async runTask(type, data) {
    const taskId = `task-${Date.now()}-${Math.random()}`;
    
    // Find available worker
    const worker = await this.getAvailableWorker();
    if (!worker) {
      throw new Error('No available workers');
    }
    
    // Mark worker as busy
    worker.busy = true;
    
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        worker.busy = false;
        reject(new Error('Task timeout'));
      }, this.config.taskTimeout);
      
      // Setup one-time listeners
      const resultHandler = (event) => {
        if (event.taskId === taskId) {
          clearTimeout(timeout);
          this.removeListener('taskCompleted', resultHandler);
          this.removeListener('taskFailed', errorHandler);
          resolve(event.result);
        }
      };
      
      const errorHandler = (event) => {
        if (event.taskId === taskId) {
          clearTimeout(timeout);
          this.removeListener('taskCompleted', resultHandler);
          this.removeListener('taskFailed', errorHandler);
          reject(new Error(event.error));
        }
      };
      
      this.once('taskCompleted', resultHandler);
      this.once('taskFailed', errorHandler);
      
      // Send task to worker
      worker.worker.postMessage({ type, taskId, data });
    });
  }

  /**
   * Get available worker
   */
  async getAvailableWorker() {
    // Try to find idle worker
    for (const worker of this.workers.values()) {
      if (!worker.busy) {
        return worker;
      }
    }
    
    // Create new worker if under limit
    if (this.workers.size &lt; this.config.maxThreads) {
      return await this.createWorker();
    }
    
    // Wait for worker to become available
    return new Promise((resolve) => {
      const checkInterval = setInterval(() => {
        for (const worker of this.workers.values()) {
          if (!worker.busy) {
            clearInterval(checkInterval);
            resolve(worker);
            return;
          }
        }
      }, 100);
    });
  }

  /**
   * Setup auto-scaling
   */
  setupAutoScaling() {
    setInterval(() => {
      const queueSize = this.taskQueue.size;
      const busyWorkers = Array.from(this.workers.values()).filter(w => w.busy).length;
      const idleWorkers = this.workers.size - busyWorkers;
      
      // Scale up if queue is building up
      if (queueSize > 10 &amp;&amp; this.workers.size &lt; this.config.maxThreads) {
        this.createWorker();
      }
      
      // Scale down if too many idle workers
      if (idleWorkers > this.config.minThreads &amp;&amp; Date.now() - this.getOldestIdleTime() > this.config.idleTimeout) {
        this.removeIdleWorker();
      }
    }, 5000);
  }

  /**
   * Get oldest idle time
   */
  getOldestIdleTime() {
    let oldest = Date.now();
    
    for (const worker of this.workers.values()) {
      if (!worker.busy &amp;&amp; worker.lastUsed &lt; oldest) {
        oldest = worker.lastUsed;
      }
    }
    
    return oldest;
  }

  /**
   * Remove an idle worker
   */
  removeIdleWorker() {
    for (const [id, worker] of this.workers.entries()) {
      if (!worker.busy &amp;&amp; this.workers.size > this.config.minThreads) {
        worker.worker.terminate();
        this.workers.delete(id);
        this.statistics.threadsDestroyed++;
        this.statistics.currentThreads--;
        break;
      }
    }
  }

  /**
   * Setup statistics collection
   */
  setupStatisticsCollection() {
    setInterval(() => {
      this.emit('statistics', this.getStatistics());
    }, 10000);
  }

  /**
   * Get statistics
   */
  getStatistics() {
    const workers = Array.from(this.workers.values());
    
    return {
      ...this.statistics,
      activeWorkers: workers.filter(w => w.busy).length,
      idleWorkers: workers.filter(w => !w.busy).length,
      queueSize: this.taskQueue.size,
      queuePending: this.taskQueue.pending,
      workerDetails: workers.map(w => ({
        id: w.id,
        busy: w.busy,
        tasksCompleted: w.tasksCompleted,
        uptime: Date.now() - w.created,
        idleTime: w.busy ? 0 : Date.now() - w.lastUsed
      }))
    };
  }

  /**
   * Cleanup resources
   */
  async cleanup() {
    this.logger.info('Cleaning up Thread Pool');
    this.shuttingDown = true;
    
    // Clear queue
    this.taskQueue.clear();
    
    // Terminate all workers
    const promises = [];
    for (const worker of this.workers.values()) {
      promises.push(worker.worker.terminate());
    }
    
    await Promise.all(promises);
    
    this.workers.clear();
    this.initialized = false;
  }
}
export default ThreadPool;
export { ThreadPool };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ABTestingManager.html">ABTestingManager</a></li><li><a href="APILoader.html">APILoader</a></li><li><a href="AnthropicAdapter.html">AnthropicAdapter</a></li><li><a href="AuditLogger.html">AuditLogger</a></li><li><a href="AuthManager.html">AuthManager</a></li><li><a href="AuthMiddleware.html">AuthMiddleware</a></li><li><a href="AzureOpenAIAdapter.html">AzureOpenAIAdapter</a></li><li><a href="BPETokenizer.html">BPETokenizer</a></li><li><a href="BaseEngine.html">BaseEngine</a></li><li><a href="BaseLoader.html">BaseLoader</a></li><li><a href="BedrockAdapter.html">BedrockAdapter</a></li><li><a href="BinaryLoader.html">BinaryLoader</a></li><li><a href="BinaryModel.html">BinaryModel</a></li><li><a href="BitNetLoader.html">BitNetLoader</a></li><li><a href="CohereAdapter.html">CohereAdapter</a></li><li><a href="ConversionConfig.html">ConversionConfig</a></li><li><a href="ConversionResult.html">ConversionResult</a></li><li><a href="DeepSeekAdapter.html">DeepSeekAdapter</a></li><li><a href="EnterpriseAuthManager.html">EnterpriseAuthManager</a></li><li><a href="EnterpriseManager.html">EnterpriseManager</a></li><li><a href="EnterpriseRouter.html">EnterpriseRouter</a></li><li><a href="ErrorHandler.html">ErrorHandler</a></li><li><a href="FireworksAdapter.html">FireworksAdapter</a></li><li><a href="FormatConverter.html">FormatConverter</a></li><li><a href="GGUFLoader.html">GGUFLoader</a></li><li><a href="GGUFModel.html">GGUFModel</a></li><li><a href="GRPCClient.html">GRPCClient</a></li><li><a href="GroqAdapter.html">GroqAdapter</a></li><li><a href="LLMRouter.html">LLMRouter</a></li><li><a href="MistralAdapter.html">MistralAdapter</a></li><li><a href="MockLoader.html">MockLoader</a></li><li><a href="MockModel.html">MockModel</a></li><li><a href="ModelError.html">ModelError</a></li><li><a href="ModelInterface.html">ModelInterface</a></li><li><a href="ModelQuantizer.html">ModelQuantizer</a></li><li><a href="ModelRegistry.html">ModelRegistry</a></li><li><a href="ModelTemplates.html">ModelTemplates</a></li><li><a href="MultiTenancyManager.html">MultiTenancyManager</a></li><li><a href="NovitaAdapter.html">NovitaAdapter</a></li><li><a href="OpenAIAdapter.html">OpenAIAdapter</a></li><li><a href="OpenRouterAdapter.html">OpenRouterAdapter</a></li><li><a href="PerplexityAdapter.html">PerplexityAdapter</a></li><li><a href="Pipeline.html">Pipeline</a></li><li><a href="PyTorchLoader.html">PyTorchLoader</a></li><li><a href="PyTorchModel.html">PyTorchModel</a></li><li><a href="QuantizationConfig.html">QuantizationConfig</a></li><li><a href="QuantizationResult.html">QuantizationResult</a></li><li><a href="Router.html">Router</a></li><li><a href="SLAMonitor.html">SLAMonitor</a></li><li><a href="SentencePieceTokenizer.html">SentencePieceTokenizer</a></li><li><a href="SimpleLoader.html">SimpleLoader</a></li><li><a href="SimpleModel.html">SimpleModel</a></li><li><a href="TogetherAdapter.html">TogetherAdapter</a></li><li><a href="TokenizationResult.html">TokenizationResult</a></li><li><a href="TokenizerConfig.html">TokenizerConfig</a></li><li><a href="UniversalTokenizer.html">UniversalTokenizer</a></li><li><a href="ValidationConfig.html">ValidationConfig</a></li><li><a href="ValidationSuite.html">ValidationSuite</a></li><li><a href="ValidationSuiteResult.html">ValidationSuiteResult</a></li><li><a href="ValidationTestResult.html">ValidationTestResult</a></li><li><a href="VertexAIAdapter.html">VertexAIAdapter</a></li><li><a href="WordPieceTokenizer.html">WordPieceTokenizer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ADAPTER_REGISTRY">ADAPTER_REGISTRY</a></li><li><a href="global.html#API_KEY_PATTERNS">API_KEY_PATTERNS</a></li><li><a href="global.html#AUTH_TYPES">AUTH_TYPES</a></li><li><a href="global.html#AZURE_API_VERSIONS">AZURE_API_VERSIONS</a></li><li><a href="global.html#AZURE_OPENAI_MODELS">AZURE_OPENAI_MODELS</a></li><li><a href="global.html#Architectures">Architectures</a></li><li><a href="global.html#AuditEventTypes">AuditEventTypes</a></li><li><a href="global.html#AuthMethods">AuthMethods</a></li><li><a href="global.html#BEDROCK_MODELS">BEDROCK_MODELS</a></li><li><a href="global.html#BreachSeverity">BreachSeverity</a></li><li><a href="global.html#CLAUDE_MODELS">CLAUDE_MODELS</a></li><li><a href="global.html#COHERE_MODELS">COHERE_MODELS</a></li><li><a href="global.html#COMPLIANCE_FEATURES">COMPLIANCE_FEATURES</a></li><li><a href="global.html#Capabilities">Capabilities</a></li><li><a href="global.html#ComplianceFrameworks">ComplianceFrameworks</a></li><li><a href="global.html#DEEPSEEK_ENDPOINTS">DEEPSEEK_ENDPOINTS</a></li><li><a href="global.html#DEEPSEEK_MODELS">DEEPSEEK_MODELS</a></li><li><a href="global.html#EnterpriseFeatures">EnterpriseFeatures</a></li><li><a href="global.html#ExperimentStatus">ExperimentStatus</a></li><li><a href="global.html#FIREWORKS_MODELS">FIREWORKS_MODELS</a></li><li><a href="global.html#GROQ_MODELS">GROQ_MODELS</a></li><li><a href="global.html#INPUT_TYPES">INPUT_TYPES</a></li><li><a href="global.html#IsolationLevels">IsolationLevels</a></li><li><a href="global.html#MISTRAL_MODELS">MISTRAL_MODELS</a></li><li><a href="global.html#MODEL_CATEGORIES">MODEL_CATEGORIES</a></li><li><a href="global.html#ModelFormat">ModelFormat</a></li><li><a href="global.html#ModelFormats">ModelFormats</a></li><li><a href="global.html#NOVITA_ENDPOINTS">NOVITA_ENDPOINTS</a></li><li><a href="global.html#NOVITA_MODELS">NOVITA_MODELS</a></li><li><a href="global.html#OPENAI_MODELS">OPENAI_MODELS</a></li><li><a href="global.html#PERPLEXITY_MODELS">PERPLEXITY_MODELS</a></li><li><a href="global.html#POPULAR_MODELS">POPULAR_MODELS</a></li><li><a href="global.html#PROVIDER_AUTH_CONFIG">PROVIDER_AUTH_CONFIG</a></li><li><a href="global.html#PROVIDER_CATEGORIES">PROVIDER_CATEGORIES</a></li><li><a href="global.html#PROVIDER_CONFIGS">PROVIDER_CONFIGS</a></li><li><a href="global.html#PROVIDER_FEATURES">PROVIDER_FEATURES</a></li><li><a href="global.html#Permissions">Permissions</a></li><li><a href="global.html#QuantizationMethod">QuantizationMethod</a></li><li><a href="global.html#QuantizationPrecision">QuantizationPrecision</a></li><li><a href="global.html#QuotaTypes">QuotaTypes</a></li><li><a href="global.html#RiskLevels">RiskLevels</a></li><li><a href="global.html#RoutingStrategies">RoutingStrategies</a></li><li><a href="global.html#SAFETY_LEVELS">SAFETY_LEVELS</a></li><li><a href="global.html#SLAMetricTypes">SLAMetricTypes</a></li><li><a href="global.html#SLAStatus">SLAStatus</a></li><li><a href="global.html#SessionTypes">SessionTypes</a></li><li><a href="global.html#SplittingAlgorithms">SplittingAlgorithms</a></li><li><a href="global.html#StatisticalTests">StatisticalTests</a></li><li><a href="global.html#TOGETHER_MODELS">TOGETHER_MODELS</a></li><li><a href="global.html#TimeWindows">TimeWindows</a></li><li><a href="global.html#TokenizerType">TokenizerType</a></li><li><a href="global.html#UserRoles">UserRoles</a></li><li><a href="global.html#VERTEX_AI_MODELS">VERTEX_AI_MODELS</a></li><li><a href="global.html#VERTEX_REGIONS">VERTEX_REGIONS</a></li><li><a href="global.html#ValidationSeverity">ValidationSeverity</a></li><li><a href="global.html#ValidationTestType">ValidationTestType</a></li><li><a href="global.html#adjustTimeouts">adjustTimeouts</a></li><li><a href="global.html#attemptRecovery">attemptRecovery</a></li><li><a href="global.html#checkConnectivity">checkConnectivity</a></li><li><a href="global.html#clearCache">clearCache</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#createAdapter">createAdapter</a></li><li><a href="global.html#createEnterpriseExpressRoutes">createEnterpriseExpressRoutes</a></li><li><a href="global.html#createEnterpriseRouter">createEnterpriseRouter</a></li><li><a href="global.html#createEnterpriseWebSocketHandlers">createEnterpriseWebSocketHandlers</a></li><li><a href="global.html#createMissingResources">createMissingResources</a></li><li><a href="global.html#defaultEnterpriseConfig">defaultEnterpriseConfig</a></li><li><a href="global.html#emergencyShutdown">emergencyShutdown</a></li><li><a href="global.html#enterpriseVersion">enterpriseVersion</a></li><li><a href="global.html#errorMonitoringMiddleware">errorMonitoringMiddleware</a></li><li><a href="global.html#escalateError">escalateError</a></li><li><a href="global.html#executeRecovery">executeRecovery</a></li><li><a href="global.html#getAdapter">getAdapter</a></li><li><a href="global.html#getEnabledFeatures">getEnabledFeatures</a></li><li><a href="global.html#getMonitoringStatus">getMonitoringStatus</a></li><li><a href="global.html#getProviderAuthType">getProviderAuthType</a></li><li><a href="global.html#getProviderInfo">getProviderInfo</a></li><li><a href="global.html#getProvidersByCategory">getProvidersByCategory</a></li><li><a href="global.html#getProvidersByFeature">getProvidersByFeature</a></li><li><a href="global.html#getStats">getStats</a></li><li><a href="global.html#getSupportedProviders">getSupportedProviders</a></li><li><a href="global.html#gracefulShutdown">gracefulShutdown</a></li><li><a href="global.html#handleCriticalError">handleCriticalError</a></li><li><a href="global.html#handleMemoryLeak">handleMemoryLeak</a></li><li><a href="global.html#httpMonitoringMiddleware">httpMonitoringMiddleware</a></li><li><a href="global.html#isFeatureEnabled">isFeatureEnabled</a></li><li><a href="global.html#isProviderSupported">isProviderSupported</a></li><li><a href="global.html#logError">logError</a></li><li><a href="global.html#performHealthCheck">performHealthCheck</a></li><li><a href="global.html#recordCustomMetric">recordCustomMetric</a></li><li><a href="global.html#registerAlertRule">registerAlertRule</a></li><li><a href="global.html#registerDependency">registerDependency</a></li><li><a href="global.html#registerHealthCheck">registerHealthCheck</a></li><li><a href="global.html#reinstallDependencies">reinstallDependencies</a></li><li><a href="global.html#reload">reload</a></li><li><a href="global.html#restartProcess">restartProcess</a></li><li><a href="global.html#retryConnection">retryConnection</a></li><li><a href="global.html#selectRecoveryStrategy">selectRecoveryStrategy</a></li><li><a href="global.html#setupHandlers">setupHandlers</a></li><li><a href="global.html#setupMonitoring">setupMonitoring</a></li><li><a href="global.html#softRestart">softRestart</a></li><li><a href="global.html#startHealthMonitoring">startHealthMonitoring</a></li><li><a href="global.html#startPerformanceProfile">startPerformanceProfile</a></li><li><a href="global.html#validateEnterpriseConfig">validateEnterpriseConfig</a></li><li><a href="global.html#withCacheMonitoring">withCacheMonitoring</a></li><li><a href="global.html#withDatabaseMonitoring">withDatabaseMonitoring</a></li><li><a href="global.html#withModelMonitoring">withModelMonitoring</a></li><li><a href="global.html#withQueueMonitoring">withQueueMonitoring</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Aug 20 2025 19:41:21 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
