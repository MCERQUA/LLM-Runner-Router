<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Model Manager - LLM Router</title>
    <link rel="stylesheet" href="/chat/model-selector-styles.css">
</head>
<body>
    <div class="model-manager">
        <!-- Header -->
        <header class="manager-header">
            <h1>ü§ñ Model Manager</h1>
            <div class="header-actions">
                <button id="refreshModels" class="btn btn-primary">üîÑ Refresh</button>
                <a href="/chat/" class="btn btn-secondary">üí¨ Back to Chat</a>
            </div>
        </header>

        <!-- Main Content -->
        <div class="manager-content">
            <!-- Currently Loaded Models -->
            <section class="loaded-models">
                <h2>üì¶ Loaded Models</h2>
                <div id="loadedModelsList" class="models-grid">
                    <!-- Loaded models will appear here -->
                </div>
            </section>

            <!-- Available Models to Download -->
            <section class="available-models">
                <h2>‚òÅÔ∏è Available Models</h2>
                <div class="model-filters">
                    <select id="modelSize" class="filter-select">
                        <option value="">All Sizes</option>
                        <option value="small">Small (< 1GB)</option>
                        <option value="medium">Medium (1-3GB)</option>
                        <option value="large">Large (3-7GB)</option>
                        <option value="xlarge">Extra Large (> 7GB)</option>
                    </select>
                    <select id="modelType" class="filter-select">
                        <option value="">All Types</option>
                        <option value="chat">Chat Models</option>
                        <option value="instruct">Instruct Models</option>
                        <option value="code">Code Models</option>
                        <option value="general">General Purpose</option>
                    </select>
                    <input type="search" id="modelSearch" placeholder="Search models..." class="search-input">
                </div>
                
                <div id="availableModelsList" class="models-grid">
                    <!-- Available models will appear here -->
                </div>
            </section>

            <!-- Model Details Panel -->
            <aside id="modelDetails" class="model-details hidden">
                <h3>Model Information</h3>
                <div id="modelInfo">
                    <!-- Model details will appear here -->
                </div>
                <div class="model-actions">
                    <button id="loadModel" class="btn btn-success hidden">Load Model</button>
                    <button id="unloadModel" class="btn btn-danger hidden">Unload Model</button>
                    <button id="downloadModel" class="btn btn-primary hidden">Download Model</button>
                    <button id="deleteModel" class="btn btn-danger hidden">Delete Model</button>
                </div>
            </aside>
        </div>

        <!-- Download Progress Modal -->
        <div id="downloadModal" class="modal hidden">
            <div class="modal-content">
                <h3>Downloading Model</h3>
                <div class="download-info">
                    <p id="downloadName">Model Name</p>
                    <div class="progress-bar">
                        <div id="downloadProgress" class="progress-fill"></div>
                    </div>
                    <p id="downloadStatus">0% - 0 MB / 0 MB</p>
                    <p id="downloadSpeed">Speed: 0 MB/s</p>
                </div>
                <button id="cancelDownload" class="btn btn-danger">Cancel</button>
            </div>
        </div>

        <!-- Notification -->
        <div id="notification" class="notification hidden">
            <span id="notificationText"></span>
        </div>
    </div>

    <script>
    // Model Manager JavaScript
    class ModelManager {
        constructor() {
            this.apiUrl = window.location.origin;
            this.loadedModels = [];
            this.availableModels = this.getAvailableModels();
            this.selectedModel = null;
            this.downloadController = null;
            
            this.init();
        }

        init() {
            this.loadModels();
            this.checkDownloadedModels().then(() => {
                this.displayAvailableModels();
            });
            this.setupEventListeners();
        }

        setupEventListeners() {
            // Refresh button
            document.getElementById('refreshModels').addEventListener('click', () => {
                this.loadModels();
            });

            // Filters
            document.getElementById('modelSize').addEventListener('change', () => {
                this.filterModels();
            });

            document.getElementById('modelType').addEventListener('change', () => {
                this.filterModels();
            });

            document.getElementById('modelSearch').addEventListener('input', (e) => {
                this.searchModels(e.target.value);
            });

            // Model actions
            document.getElementById('loadModel').addEventListener('click', () => {
                this.loadSelectedModel();
            });

            document.getElementById('unloadModel').addEventListener('click', () => {
                this.unloadSelectedModel();
            });

            document.getElementById('downloadModel').addEventListener('click', () => {
                this.downloadSelectedModel();
            });

            document.getElementById('deleteModel').addEventListener('click', () => {
                this.deleteSelectedModel();
            });

            document.getElementById('cancelDownload').addEventListener('click', () => {
                this.cancelDownload();
            });
        }

        async loadModels() {
            try {
                // Use public endpoint that doesn't require auth
                const response = await fetch(`${this.apiUrl}/api/models/public`);
                if (response.ok) {
                    const data = await response.json();
                    this.loadedModels = data.models || [];
                    this.displayLoadedModels();
                    this.showNotification('Models refreshed', 'success');
                    return;
                }
            } catch (error) {
                console.error('Failed to load models from API:', error);
            }
            
            // Fallback: Show SmolLM3 model as loaded
            console.log('Using fallback model data');
            this.loadedModels = [
                {
                    id: 'smollm3-3b',
                    name: 'SmolLM3-3B Local',
                    format: 'safetensors',
                    loaded: true,
                    local: true,
                    size: '6.2GB',
                    parameters: '3B',
                    description: 'SmolLM3-3B running locally with LLM Router knowledge',
                    capabilities: ['chat', 'instruct', 'local'],
                    provider: 'SimpleSmolLM3Loader',
                    status: 'ready'
                }
            ];
            this.displayLoadedModels();
            this.showNotification('Showing local SmolLM3 model', 'success');
        }

        displayLoadedModels() {
            const container = document.getElementById('loadedModelsList');
            container.innerHTML = '';

            if (this.loadedModels.length === 0) {
                container.innerHTML = '<p class="no-models">No models loaded. Select a model below to load.</p>';
                return;
            }

            this.loadedModels.forEach(model => {
                const card = this.createModelCard(model, true);
                container.appendChild(card);
            });
        }

        getAvailableModels() {
            // Available models including local SmolLM3-3B
            return [
                {
                    id: 'smollm3-3b',
                    name: 'SmolLM3-3B Local',
                    size: '6.2 GB',
                    sizeBytes: 6200000000,
                    type: 'chat',
                    description: 'SmolLM3-3B running locally with LLM Router knowledge - CURRENTLY ACTIVE',
                    format: 'safetensors',
                    quantization: 'fp32',
                    contextSize: 65536,
                    downloaded: true,
                    loaded: true,
                    local: true,
                    provider: 'SimpleSmolLM3Loader',
                    capabilities: ['chat', 'instruct', 'local', 'project-specific']
                },
                {
                    id: 'tinyllama-1.1b',
                    name: 'TinyLlama 1.1B Chat',
                    size: '637 MB',
                    sizeBytes: 668788096,
                    type: 'chat',
                    description: 'Compact chat model, great for testing',
                    url: 'https://huggingface.co/TheBloke/TinyLlama-1.1B-Chat-v1.0-GGUF/resolve/main/tinyllama-1.1b-chat-v1.0.Q4_K_M.gguf',
                    quantization: 'Q4_K_M',
                    contextSize: 2048,
                    downloaded: false
                },
                {
                    id: 'phi-2',
                    name: 'Phi-2 2.7B',
                    size: '1.6 GB',
                    sizeBytes: 1717986918,
                    type: 'instruct',
                    description: 'Microsoft Phi-2 model for reasoning',
                    url: 'https://huggingface.co/TheBloke/phi-2-GGUF/resolve/main/phi-2.Q4_K_M.gguf',
                    quantization: 'Q4_K_M',
                    contextSize: 2048,
                    downloaded: false
                },
                {
                    id: 'mistral-7b-instruct',
                    name: 'Mistral 7B Instruct',
                    size: '4.1 GB',
                    sizeBytes: 4404019840,
                    type: 'instruct',
                    description: 'Powerful instruction-following model',
                    url: 'https://huggingface.co/TheBloke/Mistral-7B-Instruct-v0.2-GGUF/resolve/main/mistral-7b-instruct-v0.2.Q4_K_M.gguf',
                    quantization: 'Q4_K_M',
                    contextSize: 8192,
                    downloaded: false
                },
                {
                    id: 'llama-2-7b-chat',
                    name: 'Llama 2 7B Chat',
                    size: '3.8 GB',
                    sizeBytes: 4081004160,
                    type: 'chat',
                    description: 'Meta\'s Llama 2 chat model',
                    url: 'https://huggingface.co/TheBloke/Llama-2-7B-Chat-GGUF/resolve/main/llama-2-7b-chat.Q4_K_M.gguf',
                    quantization: 'Q4_K_M',
                    contextSize: 4096,
                    downloaded: false
                },
                {
                    id: 'codellama-7b',
                    name: 'CodeLlama 7B',
                    size: '3.8 GB',
                    sizeBytes: 4081004160,
                    type: 'code',
                    description: 'Specialized for code generation',
                    url: 'https://huggingface.co/TheBloke/CodeLlama-7B-GGUF/resolve/main/codellama-7b.Q4_K_M.gguf',
                    quantization: 'Q4_K_M',
                    contextSize: 4096,
                    downloaded: false
                },
                {
                    id: 'wizard-vicuna-7b',
                    name: 'Wizard Vicuna 7B',
                    size: '3.8 GB',
                    sizeBytes: 4081004160,
                    type: 'chat',
                    description: 'Enhanced chat capabilities',
                    url: 'https://huggingface.co/TheBloke/Wizard-Vicuna-7B-Uncensored-GGUF/resolve/main/wizard-vicuna-7b-uncensored.Q4_K_M.gguf',
                    quantization: 'Q4_K_M',
                    contextSize: 2048,
                    downloaded: false
                },
                {
                    id: 'orca-mini-3b',
                    name: 'Orca Mini 3B',
                    size: '1.9 GB',
                    sizeBytes: 2040109465,
                    type: 'general',
                    description: 'Efficient general-purpose model',
                    url: 'https://huggingface.co/TheBloke/orca_mini_3B-GGUF/resolve/main/orca-mini-3b.q4_K_M.gguf',
                    quantization: 'Q4_K_M',
                    contextSize: 2048,
                    downloaded: false
                },
                {
                    id: 'stablelm-3b',
                    name: 'StableLM 3B',
                    size: '1.8 GB',
                    sizeBytes: 1932735283,
                    type: 'general',
                    description: 'Stability AI language model',
                    url: 'https://huggingface.co/TheBloke/stablelm-3b-4e1t-GGUF/resolve/main/stablelm-3b-4e1t.Q4_K_M.gguf',
                    quantization: 'Q4_K_M',
                    contextSize: 4096,
                    downloaded: false
                }
            ];
        }

        displayAvailableModels() {
            const container = document.getElementById('availableModelsList');
            container.innerHTML = '';

            this.availableModels.forEach(model => {
                const card = this.createModelCard(model, false);
                container.appendChild(card);
            });
        }

        createModelCard(model, isLoaded) {
            const card = document.createElement('div');
            card.className = `model-card ${isLoaded ? 'loaded' : ''} ${model.local ? 'local' : ''}`;
            card.innerHTML = `
                <div class="model-header">
                    <h3>${model.name}</h3>
                    ${isLoaded ? '<span class="status-badge loaded">Loaded ‚úÖ</span>' : ''}
                    ${model.downloaded ? '<span class="status-badge downloaded">Downloaded ‚úÖ</span>' : ''}
                    ${model.local ? '<span class="status-badge local">üè† Local</span>' : ''}
                    ${model.status === 'ready' ? '<span class="status-badge ready">üöÄ Ready</span>' : ''}
                </div>
                <div class="model-info">
                    <p class="model-size">üì¶ ${model.size || 'Unknown'}</p>
                    <p class="model-type">üè∑Ô∏è ${model.type || model.format || 'Unknown'}</p>
                    ${model.quantization ? `<p class="model-quant">‚ö° ${model.quantization}</p>` : ''}
                    ${model.contextSize ? `<p class="model-context">üìù ${model.contextSize.toLocaleString()} tokens</p>` : ''}
                    ${model.provider ? `<p class="model-provider">üîß ${model.provider}</p>` : ''}
                    ${model.parameters ? `<p class="model-params">üß† ${model.parameters} parameters</p>` : ''}
                </div>
                <p class="model-description">${model.description || 'No description available'}</p>
                ${model.capabilities ? `<div class="model-capabilities">
                    ${model.capabilities.map(cap => `<span class="capability-badge">${cap}</span>`).join('')}
                </div>` : ''}
            `;

            card.addEventListener('click', () => {
                this.selectModel(model);
            });

            return card;
        }

        selectModel(model) {
            this.selectedModel = model;
            this.showModelDetails(model);
        }

        showModelDetails(model) {
            const detailsPanel = document.getElementById('modelDetails');
            const infoContainer = document.getElementById('modelInfo');
            
            detailsPanel.classList.remove('hidden');
            
            infoContainer.innerHTML = `
                <h4>${model.name}</h4>
                <dl>
                    <dt>ID:</dt>
                    <dd>${model.id}</dd>
                    
                    <dt>Size:</dt>
                    <dd>${model.size || 'Unknown'}</dd>
                    
                    <dt>Type:</dt>
                    <dd>${model.type || model.format || 'Unknown'}</dd>
                    
                    ${model.quantization ? `
                    <dt>Quantization:</dt>
                    <dd>${model.quantization}</dd>
                    ` : ''}
                    
                    ${model.contextSize ? `
                    <dt>Context Size:</dt>
                    <dd>${model.contextSize} tokens</dd>
                    ` : ''}
                    
                    ${model.description ? `
                    <dt>Description:</dt>
                    <dd>${model.description}</dd>
                    ` : ''}
                </dl>
            `;

            // Show appropriate buttons
            const isLoaded = this.loadedModels.some(m => m.id === model.id);
            const isDownloaded = model.downloaded || isLoaded;

            document.getElementById('loadModel').classList.toggle('hidden', isLoaded || !isDownloaded);
            document.getElementById('unloadModel').classList.toggle('hidden', !isLoaded);
            document.getElementById('downloadModel').classList.toggle('hidden', isDownloaded);
            document.getElementById('deleteModel').classList.toggle('hidden', !isDownloaded || isLoaded);
        }

        filterModels() {
            const sizeFilter = document.getElementById('modelSize').value;
            const typeFilter = document.getElementById('modelType').value;
            
            let filtered = this.availableModels;
            
            if (sizeFilter) {
                filtered = filtered.filter(model => {
                    const sizeInGB = model.sizeBytes / (1024 * 1024 * 1024);
                    switch(sizeFilter) {
                        case 'small': return sizeInGB < 1;
                        case 'medium': return sizeInGB >= 1 && sizeInGB < 3;
                        case 'large': return sizeInGB >= 3 && sizeInGB < 7;
                        case 'xlarge': return sizeInGB >= 7;
                        default: return true;
                    }
                });
            }
            
            if (typeFilter) {
                filtered = filtered.filter(model => model.type === typeFilter);
            }
            
            this.displayFilteredModels(filtered);
        }

        searchModels(query) {
            const filtered = this.availableModels.filter(model => 
                model.name.toLowerCase().includes(query.toLowerCase()) ||
                (model.description && model.description.toLowerCase().includes(query.toLowerCase()))
            );
            this.displayFilteredModels(filtered);
        }

        displayFilteredModels(models) {
            const container = document.getElementById('availableModelsList');
            container.innerHTML = '';
            
            if (models.length === 0) {
                container.innerHTML = '<p class="no-models">No models match your filters.</p>';
                return;
            }
            
            models.forEach(model => {
                const card = this.createModelCard(model, false);
                container.appendChild(card);
            });
        }

        async loadSelectedModel() {
            if (!this.selectedModel) return;
            
            try {
                // Get the downloaded model's filename
                const filename = this.selectedModel.url ? this.selectedModel.url.split('/').pop() : `${this.selectedModel.id}.gguf`;
                const modelPath = `models/${this.selectedModel.id}/${filename}`;
                
                const response = await fetch(`${this.apiUrl}/api/models/load`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        modelId: this.selectedModel.id,
                        path: modelPath
                    })
                });
                
                if (response.ok) {
                    this.showNotification(`Model ${this.selectedModel.name} loaded successfully`, 'success');
                    this.loadModels();
                } else {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to load model');
                }
            } catch (error) {
                this.showNotification(`Failed to load model: ${error.message}`, 'error');
            }
        }

        async unloadSelectedModel() {
            if (!this.selectedModel) return;
            
            try {
                const response = await fetch(`${this.apiUrl}/api/models/unload`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        modelId: this.selectedModel.id
                    })
                });
                
                if (response.ok) {
                    this.showNotification(`Model ${this.selectedModel.name} unloaded`, 'success');
                    this.loadModels();
                } else {
                    throw new Error('Failed to unload model');
                }
            } catch (error) {
                this.showNotification(`Failed to unload model: ${error.message}`, 'error');
            }
        }

        async downloadSelectedModel() {
            if (!this.selectedModel) return;
            
            const modal = document.getElementById('downloadModal');
            modal.classList.remove('hidden');
            
            document.getElementById('downloadName').textContent = this.selectedModel.name;
            document.getElementById('downloadStatus').textContent = 'Starting download...';
            
            try {
                // Start download
                const response = await fetch(`${this.apiUrl}/api/models/download`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        modelId: this.selectedModel.id,
                        url: this.selectedModel.url
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to start download');
                }
                
                // Poll for progress
                this.pollDownloadProgress(this.selectedModel);
                
            } catch (error) {
                modal.classList.add('hidden');
                this.showNotification(`Failed to start download: ${error.message}`, 'error');
            }
        }

        async pollDownloadProgress(model) {
            const modal = document.getElementById('downloadModal');
            const progressBar = document.getElementById('downloadProgress');
            const statusText = document.getElementById('downloadStatus');
            const speedText = document.getElementById('downloadSpeed');
            
            const pollInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${this.apiUrl}/api/models/download/progress`);
                    const data = await response.json();
                    
                    // Find our download
                    const download = data.downloads.find(d => d.modelId === model.id);
                    
                    if (download) {
                        // Update progress
                        progressBar.style.width = `${download.progress}%`;
                        
                        const mbDownloaded = (download.downloaded / 1024 / 1024).toFixed(2);
                        const mbTotal = (model.sizeBytes / 1024 / 1024).toFixed(2);
                        statusText.textContent = `${download.progress}% - ${mbDownloaded} MB / ${mbTotal} MB`;
                        
                        const mbSpeed = (download.speed / 1024 / 1024).toFixed(2);
                        speedText.textContent = `Speed: ${mbSpeed} MB/s`;
                        
                        if (download.progress >= 100) {
                            clearInterval(pollInterval);
                            modal.classList.add('hidden');
                            this.showNotification(`${model.name} downloaded successfully!`, 'success');
                            
                            // Mark as downloaded and refresh
                            this.selectedModel.downloaded = true;
                            this.loadModels();
                            this.checkDownloadedModels();
                        }
                    } else {
                        // Download might be complete, check downloaded models
                        const downloaded = await this.checkIfDownloaded(model.id);
                        if (downloaded) {
                            clearInterval(pollInterval);
                            modal.classList.add('hidden');
                            this.showNotification(`${model.name} downloaded successfully!`, 'success');
                            this.selectedModel.downloaded = true;
                            this.loadModels();
                            this.checkDownloadedModels();
                        }
                    }
                } catch (error) {
                    console.error('Failed to poll progress:', error);
                }
            }, 1000);
            
            // Store interval ID for cancellation
            this.downloadPollInterval = pollInterval;
        }

        async checkIfDownloaded(modelId) {
            try {
                const response = await fetch(`${this.apiUrl}/api/models/downloaded`);
                const data = await response.json();
                return data.models.some(m => m.id === modelId);
            } catch (error) {
                return false;
            }
        }

        async checkDownloadedModels() {
            try {
                const response = await fetch(`${this.apiUrl}/api/models/downloaded`);
                if (response.ok) {
                    const data = await response.json();
                    
                    // Update available models with download status
                    for (const model of this.availableModels) {
                        model.downloaded = data.models.some(m => m.id === model.id);
                    }
                    
                    this.displayAvailableModels();
                    return;
                }
            } catch (error) {
                console.error('Failed to check downloaded models:', error);
            }
            
            // Fallback: Mark SmolLM3 as downloaded since it's available locally
            for (const model of this.availableModels) {
                if (model.id === 'smollm3-3b' || model.name.toLowerCase().includes('smollm3')) {
                    model.downloaded = true;
                }
            }
            
            this.displayAvailableModels();
        }

        cancelDownload() {
            if (this.downloadPollInterval) {
                clearInterval(this.downloadPollInterval);
                this.downloadPollInterval = null;
            }
            document.getElementById('downloadModal').classList.add('hidden');
            this.showNotification('Download cancelled', 'info');
        }

        async deleteSelectedModel() {
            if (!this.selectedModel) return;
            
            if (!confirm(`Delete ${this.selectedModel.name}? This cannot be undone.`)) {
                return;
            }
            
            try {
                const response = await fetch(`${this.apiUrl}/api/models/${this.selectedModel.id}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    this.showNotification(`Model ${this.selectedModel.name} deleted`, 'success');
                    this.selectedModel.downloaded = false;
                    this.loadModels();
                    this.checkDownloadedModels();
                } else {
                    throw new Error('Failed to delete model');
                }
            } catch (error) {
                this.showNotification(`Failed to delete model: ${error.message}`, 'error');
            }
        }

        showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            const text = document.getElementById('notificationText');
            
            notification.className = `notification ${type}`;
            text.textContent = message;
            notification.classList.remove('hidden');
            
            setTimeout(() => {
                notification.classList.add('hidden');
            }, 3000);
        }
    }

    // Initialize manager
    const modelManager = new ModelManager();
    </script>
</body>
</html>