<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: services/ModelDownloader.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: services/ModelDownloader.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * ðŸš€ Model Downloader Service
 * Handles downloading models from HuggingFace with progress tracking
 */

import fs from 'fs';
import path from 'path';
import https from 'https';
import { pipeline } from 'stream';
import { promisify } from 'util';
import { Logger } from '../utils/Logger.js';

const streamPipeline = promisify(pipeline);
const logger = new Logger('ModelDownloader');

class ModelDownloader {
  constructor() {
    this.downloads = new Map(); // Track active downloads
    this.modelsDir = path.join(process.cwd(), 'models');
  }

  /**
   * Download a model from URL with progress tracking
   */
  async download(modelId, url, options = {}) {
    const downloadId = `${modelId}_${Date.now()}`;
    
    // Create download tracking object
    const download = {
      id: downloadId,
      modelId,
      url,
      progress: 0,
      downloaded: 0,
      total: 0,
      speed: 0,
      status: 'starting',
      startTime: Date.now(),
      abortController: new AbortController()
    };
    
    this.downloads.set(downloadId, download);
    
    try {
      // Ensure models directory exists
      const modelDir = path.join(this.modelsDir, modelId);
      await this.ensureDirectory(modelDir);
      
      // Determine filename from URL
      const filename = url.split('/').pop();
      const filepath = path.join(modelDir, filename);
      
      // Check if file already exists
      if (fs.existsSync(filepath)) {
        download.status = 'completed';
        download.progress = 100;
        download.filepath = filepath;
        logger.info(`Model already exists: ${filepath}`);
        return download;
      }
      
      // Download the file
      logger.info(`Starting download: ${modelId} from ${url}`);
      download.status = 'downloading';
      
      await this.downloadFile(url, filepath, download);
      
      download.status = 'completed';
      download.progress = 100;
      download.filepath = filepath;
      download.endTime = Date.now();
      
      logger.success(`âœ… Download completed: ${modelId}`);
      return download;
      
    } catch (error) {
      download.status = 'failed';
      download.error = error.message;
      logger.error(`Download failed: ${error.message}`);
      throw error;
      
    } finally {
      // Clean up after some time
      setTimeout(() => {
        this.downloads.delete(downloadId);
      }, 60000); // Keep for 1 minute
    }
  }

  /**
   * Download file with progress tracking
   */
  async downloadFile(url, filepath, download) {
    return new Promise((resolve, reject) => {
      // Handle redirects by following them
      const makeRequest = (requestUrl) => {
        https.get(requestUrl, (response) => {
          // Handle redirects
          if (response.statusCode === 301 || response.statusCode === 302) {
            makeRequest(response.headers.location);
            return;
          }
          
          if (response.statusCode !== 200) {
            reject(new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`));
            return;
          }
          
          // Get total size
          const totalSize = parseInt(response.headers['content-length'], 10);
          download.total = totalSize;
          
          // Create write stream
          const writeStream = fs.createWriteStream(filepath);
          
          // Track progress
          let downloaded = 0;
          let lastTime = Date.now();
          let lastDownloaded = 0;
          
          response.on('data', (chunk) => {
            downloaded += chunk.length;
            download.downloaded = downloaded;
            download.progress = Math.round((downloaded / totalSize) * 100);
            
            // Calculate speed every second
            const now = Date.now();
            if (now - lastTime > 1000) {
              const bytesPerSecond = (downloaded - lastDownloaded) / ((now - lastTime) / 1000);
              download.speed = bytesPerSecond;
              lastTime = now;
              lastDownloaded = downloaded;
              
              // Log progress
              const mbDownloaded = (downloaded / 1024 / 1024).toFixed(2);
              const mbTotal = (totalSize / 1024 / 1024).toFixed(2);
              const mbSpeed = (bytesPerSecond / 1024 / 1024).toFixed(2);
              logger.info(`Downloading ${download.modelId}: ${download.progress}% (${mbDownloaded}/${mbTotal} MB) @ ${mbSpeed} MB/s`);
            }
          });
          
          // Pipe to file
          pipeline(response, writeStream, (error) => {
            if (error) {
              // Delete partial file on error
              fs.unlinkSync(filepath);
              reject(error);
            } else {
              resolve();
            }
          });
          
          // Handle abort
          download.abortController.signal.addEventListener('abort', () => {
            response.destroy();
            writeStream.destroy();
            fs.unlinkSync(filepath);
            reject(new Error('Download cancelled'));
          });
          
        }).on('error', reject);
      };
      
      makeRequest(url);
    });
  }

  /**
   * Get download progress
   */
  getProgress(downloadId) {
    const download = this.downloads.get(downloadId);
    if (!download) return null;
    
    return {
      modelId: download.modelId,
      progress: download.progress,
      downloaded: download.downloaded,
      total: download.total,
      speed: download.speed,
      status: download.status,
      error: download.error
    };
  }

  /**
   * Cancel a download
   */
  cancel(downloadId) {
    const download = this.downloads.get(downloadId);
    if (download &amp;&amp; download.status === 'downloading') {
      download.abortController.abort();
      download.status = 'cancelled';
      return true;
    }
    return false;
  }

  /**
   * Get all active downloads
   */
  getActiveDownloads() {
    const active = [];
    for (const [id, download] of this.downloads) {
      if (download.status === 'downloading') {
        active.push({
          id,
          modelId: download.modelId,
          progress: download.progress,
          speed: download.speed
        });
      }
    }
    return active;
  }

  /**
   * Check if a model is already downloaded
   */
  async isDownloaded(modelId, filename) {
    const filepath = path.join(this.modelsDir, modelId, filename);
    return fs.existsSync(filepath);
  }

  /**
   * Get path to downloaded model
   */
  getModelPath(modelId, filename) {
    return path.join(this.modelsDir, modelId, filename);
  }

  /**
   * List all downloaded models
   */
  async listDownloaded() {
    const models = [];
    
    if (!fs.existsSync(this.modelsDir)) {
      return models;
    }
    
    const dirs = fs.readdirSync(this.modelsDir);
    
    for (const dir of dirs) {
      const modelPath = path.join(this.modelsDir, dir);
      const stat = fs.statSync(modelPath);
      
      if (stat.isDirectory()) {
        const files = fs.readdirSync(modelPath);
        const ggufFiles = files.filter(f => f.endsWith('.gguf'));
        
        for (const file of ggufFiles) {
          const filepath = path.join(modelPath, file);
          const fileStat = fs.statSync(filepath);
          
          models.push({
            id: dir,
            filename: file,
            path: filepath,
            size: fileStat.size,
            modified: fileStat.mtime
          });
        }
      }
    }
    
    return models;
  }

  /**
   * Delete a downloaded model
   */
  async deleteModel(modelId) {
    const modelPath = path.join(this.modelsDir, modelId);
    
    if (fs.existsSync(modelPath)) {
      // Remove directory and all files
      fs.rmSync(modelPath, { recursive: true, force: true });
      logger.info(`Deleted model: ${modelId}`);
      return true;
    }
    
    return false;
  }

  /**
   * Ensure directory exists
   */
  async ensureDirectory(dir) {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }

  /**
   * Calculate storage used by models
   */
  async getStorageUsed() {
    if (!fs.existsSync(this.modelsDir)) {
      return 0;
    }
    
    let totalSize = 0;
    
    const calculateSize = (dirPath) => {
      const files = fs.readdirSync(dirPath);
      
      for (const file of files) {
        const filepath = path.join(dirPath, file);
        const stat = fs.statSync(filepath);
        
        if (stat.isDirectory()) {
          calculateSize(filepath);
        } else {
          totalSize += stat.size;
        }
      }
    };
    
    calculateSize(this.modelsDir);
    return totalSize;
  }
}

// Export singleton instance
export const modelDownloader = new ModelDownloader();
export default ModelDownloader;
export { ModelDownloader };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ABTestingManager.html">ABTestingManager</a></li><li><a href="AuditLogger.html">AuditLogger</a></li><li><a href="AuthMiddleware.html">AuthMiddleware</a></li><li><a href="BPETokenizer.html">BPETokenizer</a></li><li><a href="BaseEngine.html">BaseEngine</a></li><li><a href="BaseLoader.html">BaseLoader</a></li><li><a href="BinaryLoader.html">BinaryLoader</a></li><li><a href="BinaryModel.html">BinaryModel</a></li><li><a href="BitNetLoader.html">BitNetLoader</a></li><li><a href="ConversionConfig.html">ConversionConfig</a></li><li><a href="ConversionResult.html">ConversionResult</a></li><li><a href="EnterpriseAuthManager.html">EnterpriseAuthManager</a></li><li><a href="EnterpriseManager.html">EnterpriseManager</a></li><li><a href="EnterpriseRouter.html">EnterpriseRouter</a></li><li><a href="ErrorHandler.html">ErrorHandler</a></li><li><a href="FormatConverter.html">FormatConverter</a></li><li><a href="GGUFLoader.html">GGUFLoader</a></li><li><a href="GGUFModel.html">GGUFModel</a></li><li><a href="GRPCClient.html">GRPCClient</a></li><li><a href="LLMRouter.html">LLMRouter</a></li><li><a href="MockLoader.html">MockLoader</a></li><li><a href="MockModel.html">MockModel</a></li><li><a href="ModelError.html">ModelError</a></li><li><a href="ModelInterface.html">ModelInterface</a></li><li><a href="ModelQuantizer.html">ModelQuantizer</a></li><li><a href="ModelRegistry.html">ModelRegistry</a></li><li><a href="ModelTemplates.html">ModelTemplates</a></li><li><a href="MultiTenancyManager.html">MultiTenancyManager</a></li><li><a href="Pipeline.html">Pipeline</a></li><li><a href="PyTorchLoader.html">PyTorchLoader</a></li><li><a href="PyTorchModel.html">PyTorchModel</a></li><li><a href="QuantizationConfig.html">QuantizationConfig</a></li><li><a href="QuantizationResult.html">QuantizationResult</a></li><li><a href="Router.html">Router</a></li><li><a href="SLAMonitor.html">SLAMonitor</a></li><li><a href="SentencePieceTokenizer.html">SentencePieceTokenizer</a></li><li><a href="SimpleLoader.html">SimpleLoader</a></li><li><a href="SimpleModel.html">SimpleModel</a></li><li><a href="TokenizationResult.html">TokenizationResult</a></li><li><a href="TokenizerConfig.html">TokenizerConfig</a></li><li><a href="UniversalTokenizer.html">UniversalTokenizer</a></li><li><a href="ValidationConfig.html">ValidationConfig</a></li><li><a href="ValidationSuite.html">ValidationSuite</a></li><li><a href="ValidationSuiteResult.html">ValidationSuiteResult</a></li><li><a href="ValidationTestResult.html">ValidationTestResult</a></li><li><a href="WordPieceTokenizer.html">WordPieceTokenizer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Architectures">Architectures</a></li><li><a href="global.html#AuditEventTypes">AuditEventTypes</a></li><li><a href="global.html#AuthMethods">AuthMethods</a></li><li><a href="global.html#BreachSeverity">BreachSeverity</a></li><li><a href="global.html#Capabilities">Capabilities</a></li><li><a href="global.html#ComplianceFrameworks">ComplianceFrameworks</a></li><li><a href="global.html#EnterpriseFeatures">EnterpriseFeatures</a></li><li><a href="global.html#ExperimentStatus">ExperimentStatus</a></li><li><a href="global.html#IsolationLevels">IsolationLevels</a></li><li><a href="global.html#ModelFormat">ModelFormat</a></li><li><a href="global.html#ModelFormats">ModelFormats</a></li><li><a href="global.html#Permissions">Permissions</a></li><li><a href="global.html#QuantizationMethod">QuantizationMethod</a></li><li><a href="global.html#QuantizationPrecision">QuantizationPrecision</a></li><li><a href="global.html#QuotaTypes">QuotaTypes</a></li><li><a href="global.html#RiskLevels">RiskLevels</a></li><li><a href="global.html#RoutingStrategies">RoutingStrategies</a></li><li><a href="global.html#SLAMetricTypes">SLAMetricTypes</a></li><li><a href="global.html#SLAStatus">SLAStatus</a></li><li><a href="global.html#SessionTypes">SessionTypes</a></li><li><a href="global.html#SplittingAlgorithms">SplittingAlgorithms</a></li><li><a href="global.html#StatisticalTests">StatisticalTests</a></li><li><a href="global.html#TimeWindows">TimeWindows</a></li><li><a href="global.html#TokenizerType">TokenizerType</a></li><li><a href="global.html#UserRoles">UserRoles</a></li><li><a href="global.html#ValidationSeverity">ValidationSeverity</a></li><li><a href="global.html#ValidationTestType">ValidationTestType</a></li><li><a href="global.html#adjustTimeouts">adjustTimeouts</a></li><li><a href="global.html#attemptRecovery">attemptRecovery</a></li><li><a href="global.html#checkConnectivity">checkConnectivity</a></li><li><a href="global.html#clearCache">clearCache</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#createEnterpriseExpressRoutes">createEnterpriseExpressRoutes</a></li><li><a href="global.html#createEnterpriseRouter">createEnterpriseRouter</a></li><li><a href="global.html#createEnterpriseWebSocketHandlers">createEnterpriseWebSocketHandlers</a></li><li><a href="global.html#createMissingResources">createMissingResources</a></li><li><a href="global.html#defaultEnterpriseConfig">defaultEnterpriseConfig</a></li><li><a href="global.html#emergencyShutdown">emergencyShutdown</a></li><li><a href="global.html#enterpriseVersion">enterpriseVersion</a></li><li><a href="global.html#errorMonitoringMiddleware">errorMonitoringMiddleware</a></li><li><a href="global.html#escalateError">escalateError</a></li><li><a href="global.html#executeRecovery">executeRecovery</a></li><li><a href="global.html#getEnabledFeatures">getEnabledFeatures</a></li><li><a href="global.html#getMonitoringStatus">getMonitoringStatus</a></li><li><a href="global.html#getStats">getStats</a></li><li><a href="global.html#gracefulShutdown">gracefulShutdown</a></li><li><a href="global.html#handleCriticalError">handleCriticalError</a></li><li><a href="global.html#handleMemoryLeak">handleMemoryLeak</a></li><li><a href="global.html#httpMonitoringMiddleware">httpMonitoringMiddleware</a></li><li><a href="global.html#isFeatureEnabled">isFeatureEnabled</a></li><li><a href="global.html#logError">logError</a></li><li><a href="global.html#performHealthCheck">performHealthCheck</a></li><li><a href="global.html#recordCustomMetric">recordCustomMetric</a></li><li><a href="global.html#registerAlertRule">registerAlertRule</a></li><li><a href="global.html#registerDependency">registerDependency</a></li><li><a href="global.html#registerHealthCheck">registerHealthCheck</a></li><li><a href="global.html#reinstallDependencies">reinstallDependencies</a></li><li><a href="global.html#reload">reload</a></li><li><a href="global.html#restartProcess">restartProcess</a></li><li><a href="global.html#retryConnection">retryConnection</a></li><li><a href="global.html#selectRecoveryStrategy">selectRecoveryStrategy</a></li><li><a href="global.html#setupHandlers">setupHandlers</a></li><li><a href="global.html#setupMonitoring">setupMonitoring</a></li><li><a href="global.html#softRestart">softRestart</a></li><li><a href="global.html#startHealthMonitoring">startHealthMonitoring</a></li><li><a href="global.html#startPerformanceProfile">startPerformanceProfile</a></li><li><a href="global.html#validateEnterpriseConfig">validateEnterpriseConfig</a></li><li><a href="global.html#withCacheMonitoring">withCacheMonitoring</a></li><li><a href="global.html#withDatabaseMonitoring">withDatabaseMonitoring</a></li><li><a href="global.html#withModelMonitoring">withModelMonitoring</a></li><li><a href="global.html#withQueueMonitoring">withQueueMonitoring</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Mon Aug 18 2025 01:43:35 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
