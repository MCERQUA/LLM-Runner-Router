<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: runtime/MemoryManager.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: runtime/MemoryManager.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Memory Manager
 * Advanced memory optimization for model loading and inference
 * Handles memory mapping, pooling, and garbage collection
 */

import { Logger } from '../utils/Logger.js';
import os from 'os';
import { performance } from 'perf_hooks';

class MemoryManager {
  constructor(config = {}) {
    this.logger = new Logger('MemoryManager');
    this.config = {
      maxMemoryUsage: config.maxMemoryUsage || 0.8, // 80% of available memory
      gcThreshold: config.gcThreshold || 0.7, // Trigger GC at 70% usage
      poolSize: config.poolSize || 10, // Buffer pool size
      enableMemoryMapping: config.enableMemoryMapping !== false,
      enableCompression: config.enableCompression !== false,
      monitoringInterval: config.monitoringInterval || 5000 // 5 seconds
    };
    
    this.models = new Map();
    this.bufferPool = [];
    this.statistics = {
      totalAllocated: 0,
      totalFreed: 0,
      peakUsage: 0,
      gcCount: 0,
      swapCount: 0
    };
    
    this.monitoring = null;
    this.compressionCache = new Map();
  }

  /**
   * Initialize memory manager
   */
  async initialize() {
    this.logger.info('Initializing Memory Manager');
    
    // Initialize buffer pool
    this.initializeBufferPool();
    
    // Start memory monitoring
    this.startMonitoring();
    
    // Set up process memory hooks
    this.setupMemoryHooks();
    
    return true;
  }

  /**
   * Initialize pre-allocated buffer pool
   */
  initializeBufferPool() {
    const bufferSize = 1024 * 1024; // 1MB buffers
    
    for (let i = 0; i &lt; this.config.poolSize; i++) {
      this.bufferPool.push({
        buffer: Buffer.allocUnsafe(bufferSize),
        inUse: false,
        size: bufferSize
      });
    }
    
    this.logger.debug(`Buffer pool initialized with ${this.config.poolSize} buffers`);
  }

  /**
   * Start memory monitoring
   */
  startMonitoring() {
    if (this.monitoring) {
      clearInterval(this.monitoring);
    }
    
    this.monitoring = setInterval(() => {
      this.checkMemoryUsage();
    }, this.config.monitoringInterval);
  }

  /**
   * Stop memory monitoring
   */
  stopMonitoring() {
    if (this.monitoring) {
      clearInterval(this.monitoring);
      this.monitoring = null;
    }
  }

  /**
   * Set up process memory hooks
   */
  setupMemoryHooks() {
    // Handle process warnings
    process.on('warning', (warning) => {
      if (warning.name === 'MaxListenersExceededWarning') {
        this.logger.warn('Memory pressure detected - max listeners exceeded');
        this.performGarbageCollection();
      }
    });
    
    // Monitor for memory pressure
    if (global.gc) {
      // If --expose-gc flag is used
      const originalGc = global.gc;
      global.gc = () => {
        this.statistics.gcCount++;
        originalGc();
      };
    }
  }

  /**
   * Check current memory usage
   */
  checkMemoryUsage() {
    const usage = process.memoryUsage();
    const totalMemory = os.totalmem();
    const freeMemory = os.freemem();
    const usedMemory = totalMemory - freeMemory;
    const usageRatio = usedMemory / totalMemory;
    
    // Update statistics
    this.statistics.peakUsage = Math.max(this.statistics.peakUsage, usage.heapUsed);
    
    // Check if we need to trigger GC
    if (usageRatio > this.config.gcThreshold) {
      this.logger.warn(`Memory usage at ${(usageRatio * 100).toFixed(2)}% - triggering GC`);
      this.performGarbageCollection();
    }
    
    // Check if we need to swap models
    if (usageRatio > this.config.maxMemoryUsage) {
      this.logger.warn(`Memory usage critical at ${(usageRatio * 100).toFixed(2)}% - swapping models`);
      this.swapLeastUsedModel();
    }
    
    return {
      heapUsed: usage.heapUsed,
      heapTotal: usage.heapTotal,
      external: usage.external,
      freeMemory,
      totalMemory,
      usageRatio
    };
  }

  /**
   * Allocate memory for a model
   */
  async allocateModelMemory(modelId, sizeEstimate) {
    const memoryInfo = this.checkMemoryUsage();
    
    // Check if we have enough memory
    const requiredMemory = sizeEstimate || 100 * 1024 * 1024; // Default 100MB
    const availableMemory = memoryInfo.freeMemory;
    
    if (requiredMemory > availableMemory * 0.9) {
      // Not enough memory - try to free some
      this.logger.warn(`Insufficient memory for model ${modelId} - attempting to free memory`);
      await this.freeMemory(requiredMemory);
    }
    
    // Track allocation
    this.models.set(modelId, {
      size: requiredMemory,
      allocated: Date.now(),
      lastAccessed: Date.now(),
      accessCount: 0,
      compressed: false,
      swapped: false
    });
    
    this.statistics.totalAllocated += requiredMemory;
    
    this.logger.debug(`Allocated ${(requiredMemory / 1024 / 1024).toFixed(2)}MB for model ${modelId}`);
    
    return true;
  }

  /**
   * Free memory by removing least recently used models
   */
  async freeMemory(requiredBytes) {
    const models = Array.from(this.models.entries())
      .sort((a, b) => a[1].lastAccessed - b[1].lastAccessed);
    
    let freedBytes = 0;
    
    for (const [modelId, info] of models) {
      if (freedBytes >= requiredBytes) break;
      
      if (!info.swapped) {
        // Try compression first
        if (!info.compressed &amp;&amp; this.config.enableCompression) {
          await this.compressModel(modelId);
          freedBytes += info.size * 0.5; // Assume 50% compression
        } else {
          // Swap to disk
          await this.swapModelToDisk(modelId);
          freedBytes += info.size;
        }
      }
    }
    
    this.statistics.totalFreed += freedBytes;
    
    return freedBytes;
  }

  /**
   * Compress model in memory
   */
  async compressModel(modelId) {
    const info = this.models.get(modelId);
    if (!info || info.compressed) return;
    
    this.logger.debug(`Compressing model ${modelId}`);
    
    // Simulate compression (in real implementation, would use actual compression)
    info.compressed = true;
    info.size = info.size * 0.5; // Assume 50% compression ratio
    
    this.compressionCache.set(modelId, {
      compressed: true,
      originalSize: info.size * 2,
      compressionRatio: 0.5
    });
  }

  /**
   * Decompress model
   */
  async decompressModel(modelId) {
    const info = this.models.get(modelId);
    if (!info || !info.compressed) return;
    
    const compressionInfo = this.compressionCache.get(modelId);
    if (compressionInfo) {
      info.size = compressionInfo.originalSize;
      info.compressed = false;
      this.compressionCache.delete(modelId);
    }
  }

  /**
   * Swap model to disk
   */
  async swapModelToDisk(modelId) {
    const info = this.models.get(modelId);
    if (!info || info.swapped) return;
    
    this.logger.info(`Swapping model ${modelId} to disk`);
    
    // In real implementation, would write to disk
    info.swapped = true;
    this.statistics.swapCount++;
    
    // Free the memory
    this.statistics.totalFreed += info.size;
  }

  /**
   * Load model from disk
   */
  async loadModelFromDisk(modelId) {
    const info = this.models.get(modelId);
    if (!info || !info.swapped) return;
    
    this.logger.info(`Loading model ${modelId} from disk`);
    
    // Check available memory
    await this.allocateModelMemory(modelId, info.size);
    
    // In real implementation, would read from disk
    info.swapped = false;
    info.lastAccessed = Date.now();
    info.accessCount++;
  }

  /**
   * Swap least recently used model
   */
  async swapLeastUsedModel() {
    const models = Array.from(this.models.entries())
      .filter(([_, info]) => !info.swapped)
      .sort((a, b) => a[1].lastAccessed - b[1].lastAccessed);
    
    if (models.length > 0) {
      const [modelId] = models[0];
      await this.swapModelToDisk(modelId);
    }
  }

  /**
   * Perform garbage collection
   */
  performGarbageCollection() {
    this.logger.debug('Performing garbage collection');
    
    if (global.gc) {
      global.gc();
    } else {
      // Trigger GC indirectly
      const arrays = [];
      try {
        while (true) {
          arrays.push(new Array(1000000));
        }
      } catch (e) {
        // Memory pressure will trigger GC
        arrays.length = 0;
      }
    }
    
    this.statistics.gcCount++;
  }

  /**
   * Get buffer from pool
   */
  getPooledBuffer(size) {
    // Find available buffer of appropriate size
    const buffer = this.bufferPool.find(b => !b.inUse &amp;&amp; b.size >= size);
    
    if (buffer) {
      buffer.inUse = true;
      return buffer.buffer.slice(0, size);
    }
    
    // No suitable buffer in pool, allocate new one
    return Buffer.allocUnsafe(size);
  }

  /**
   * Return buffer to pool
   */
  returnPooledBuffer(buffer) {
    const poolBuffer = this.bufferPool.find(b => b.buffer === buffer);
    if (poolBuffer) {
      poolBuffer.inUse = false;
    }
  }

  /**
   * Memory-map a file
   */
  async memoryMapFile(filePath, modelId) {
    if (!this.config.enableMemoryMapping) {
      return null;
    }
    
    try {
      // In Node.js, we can use mmap-io or similar libraries
      // For now, this is a placeholder
      this.logger.debug(`Memory-mapping file ${filePath} for model ${modelId}`);
      
      // Track the mapping
      const info = this.models.get(modelId);
      if (info) {
        info.memoryMapped = true;
      }
      
      return true;
    } catch (error) {
      this.logger.error(`Failed to memory-map file: ${error.message}`);
      return false;
    }
  }

  /**
   * Update model access statistics
   */
  updateModelAccess(modelId) {
    const info = this.models.get(modelId);
    if (info) {
      info.lastAccessed = Date.now();
      info.accessCount++;
      
      // Load from disk if swapped
      if (info.swapped) {
        this.loadModelFromDisk(modelId);
      }
      
      // Decompress if compressed
      if (info.compressed) {
        this.decompressModel(modelId);
      }
    }
  }

  /**
   * Get memory statistics
   */
  getStatistics() {
    const memoryInfo = this.checkMemoryUsage();
    
    return {
      ...this.statistics,
      currentUsage: memoryInfo,
      models: Array.from(this.models.entries()).map(([id, info]) => ({
        id,
        size: info.size,
        compressed: info.compressed,
        swapped: info.swapped,
        lastAccessed: new Date(info.lastAccessed).toISOString(),
        accessCount: info.accessCount
      })),
      bufferPool: {
        total: this.bufferPool.length,
        inUse: this.bufferPool.filter(b => b.inUse).length,
        available: this.bufferPool.filter(b => !b.inUse).length
      }
    };
  }

  /**
   * Optimize memory layout
   */
  async optimizeMemoryLayout() {
    this.logger.info('Optimizing memory layout');
    
    // Sort models by access frequency
    const models = Array.from(this.models.entries())
      .sort((a, b) => b[1].accessCount - a[1].accessCount);
    
    // Keep frequently accessed models in memory
    // Compress or swap less frequently used ones
    for (const [modelId, info] of models) {
      const accessRate = info.accessCount / ((Date.now() - info.allocated) / 1000 / 60); // accesses per minute
      
      if (accessRate &lt; 0.1 &amp;&amp; !info.swapped) {
        // Very low access rate - swap to disk
        await this.swapModelToDisk(modelId);
      } else if (accessRate &lt; 1 &amp;&amp; !info.compressed) {
        // Low access rate - compress
        await this.compressModel(modelId);
      }
    }
  }

  /**
   * Clean up resources
   */
  async cleanup() {
    this.logger.info('Cleaning up Memory Manager');
    
    // Stop monitoring
    this.stopMonitoring();
    
    // Clear caches
    this.compressionCache.clear();
    this.models.clear();
    
    // Clear buffer pool
    this.bufferPool = [];
    
    // Force GC
    this.performGarbageCollection();
  }
}
export default MemoryManager;
export { MemoryManager };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ABTestingManager.html">ABTestingManager</a></li><li><a href="AuditLogger.html">AuditLogger</a></li><li><a href="AuthMiddleware.html">AuthMiddleware</a></li><li><a href="BPETokenizer.html">BPETokenizer</a></li><li><a href="BaseEngine.html">BaseEngine</a></li><li><a href="BaseLoader.html">BaseLoader</a></li><li><a href="BinaryLoader.html">BinaryLoader</a></li><li><a href="BinaryModel.html">BinaryModel</a></li><li><a href="BitNetLoader.html">BitNetLoader</a></li><li><a href="ConversionConfig.html">ConversionConfig</a></li><li><a href="ConversionResult.html">ConversionResult</a></li><li><a href="EnterpriseAuthManager.html">EnterpriseAuthManager</a></li><li><a href="EnterpriseManager.html">EnterpriseManager</a></li><li><a href="EnterpriseRouter.html">EnterpriseRouter</a></li><li><a href="ErrorHandler.html">ErrorHandler</a></li><li><a href="FormatConverter.html">FormatConverter</a></li><li><a href="GGUFLoader.html">GGUFLoader</a></li><li><a href="GGUFModel.html">GGUFModel</a></li><li><a href="GRPCClient.html">GRPCClient</a></li><li><a href="LLMRouter.html">LLMRouter</a></li><li><a href="MockLoader.html">MockLoader</a></li><li><a href="MockModel.html">MockModel</a></li><li><a href="ModelError.html">ModelError</a></li><li><a href="ModelInterface.html">ModelInterface</a></li><li><a href="ModelQuantizer.html">ModelQuantizer</a></li><li><a href="ModelRegistry.html">ModelRegistry</a></li><li><a href="ModelTemplates.html">ModelTemplates</a></li><li><a href="MultiTenancyManager.html">MultiTenancyManager</a></li><li><a href="Pipeline.html">Pipeline</a></li><li><a href="PyTorchLoader.html">PyTorchLoader</a></li><li><a href="PyTorchModel.html">PyTorchModel</a></li><li><a href="QuantizationConfig.html">QuantizationConfig</a></li><li><a href="QuantizationResult.html">QuantizationResult</a></li><li><a href="Router.html">Router</a></li><li><a href="SLAMonitor.html">SLAMonitor</a></li><li><a href="SentencePieceTokenizer.html">SentencePieceTokenizer</a></li><li><a href="SimpleLoader.html">SimpleLoader</a></li><li><a href="SimpleModel.html">SimpleModel</a></li><li><a href="TokenizationResult.html">TokenizationResult</a></li><li><a href="TokenizerConfig.html">TokenizerConfig</a></li><li><a href="UniversalTokenizer.html">UniversalTokenizer</a></li><li><a href="ValidationConfig.html">ValidationConfig</a></li><li><a href="ValidationSuite.html">ValidationSuite</a></li><li><a href="ValidationSuiteResult.html">ValidationSuiteResult</a></li><li><a href="ValidationTestResult.html">ValidationTestResult</a></li><li><a href="WordPieceTokenizer.html">WordPieceTokenizer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Architectures">Architectures</a></li><li><a href="global.html#AuditEventTypes">AuditEventTypes</a></li><li><a href="global.html#AuthMethods">AuthMethods</a></li><li><a href="global.html#BreachSeverity">BreachSeverity</a></li><li><a href="global.html#Capabilities">Capabilities</a></li><li><a href="global.html#ComplianceFrameworks">ComplianceFrameworks</a></li><li><a href="global.html#EnterpriseFeatures">EnterpriseFeatures</a></li><li><a href="global.html#ExperimentStatus">ExperimentStatus</a></li><li><a href="global.html#IsolationLevels">IsolationLevels</a></li><li><a href="global.html#ModelFormat">ModelFormat</a></li><li><a href="global.html#ModelFormats">ModelFormats</a></li><li><a href="global.html#Permissions">Permissions</a></li><li><a href="global.html#QuantizationMethod">QuantizationMethod</a></li><li><a href="global.html#QuantizationPrecision">QuantizationPrecision</a></li><li><a href="global.html#QuotaTypes">QuotaTypes</a></li><li><a href="global.html#RiskLevels">RiskLevels</a></li><li><a href="global.html#RoutingStrategies">RoutingStrategies</a></li><li><a href="global.html#SLAMetricTypes">SLAMetricTypes</a></li><li><a href="global.html#SLAStatus">SLAStatus</a></li><li><a href="global.html#SessionTypes">SessionTypes</a></li><li><a href="global.html#SplittingAlgorithms">SplittingAlgorithms</a></li><li><a href="global.html#StatisticalTests">StatisticalTests</a></li><li><a href="global.html#TimeWindows">TimeWindows</a></li><li><a href="global.html#TokenizerType">TokenizerType</a></li><li><a href="global.html#UserRoles">UserRoles</a></li><li><a href="global.html#ValidationSeverity">ValidationSeverity</a></li><li><a href="global.html#ValidationTestType">ValidationTestType</a></li><li><a href="global.html#adjustTimeouts">adjustTimeouts</a></li><li><a href="global.html#attemptRecovery">attemptRecovery</a></li><li><a href="global.html#checkConnectivity">checkConnectivity</a></li><li><a href="global.html#clearCache">clearCache</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#createEnterpriseExpressRoutes">createEnterpriseExpressRoutes</a></li><li><a href="global.html#createEnterpriseRouter">createEnterpriseRouter</a></li><li><a href="global.html#createEnterpriseWebSocketHandlers">createEnterpriseWebSocketHandlers</a></li><li><a href="global.html#createMissingResources">createMissingResources</a></li><li><a href="global.html#defaultEnterpriseConfig">defaultEnterpriseConfig</a></li><li><a href="global.html#emergencyShutdown">emergencyShutdown</a></li><li><a href="global.html#enterpriseVersion">enterpriseVersion</a></li><li><a href="global.html#errorMonitoringMiddleware">errorMonitoringMiddleware</a></li><li><a href="global.html#escalateError">escalateError</a></li><li><a href="global.html#executeRecovery">executeRecovery</a></li><li><a href="global.html#getEnabledFeatures">getEnabledFeatures</a></li><li><a href="global.html#getMonitoringStatus">getMonitoringStatus</a></li><li><a href="global.html#getStats">getStats</a></li><li><a href="global.html#gracefulShutdown">gracefulShutdown</a></li><li><a href="global.html#handleCriticalError">handleCriticalError</a></li><li><a href="global.html#handleMemoryLeak">handleMemoryLeak</a></li><li><a href="global.html#httpMonitoringMiddleware">httpMonitoringMiddleware</a></li><li><a href="global.html#isFeatureEnabled">isFeatureEnabled</a></li><li><a href="global.html#logError">logError</a></li><li><a href="global.html#performHealthCheck">performHealthCheck</a></li><li><a href="global.html#recordCustomMetric">recordCustomMetric</a></li><li><a href="global.html#registerAlertRule">registerAlertRule</a></li><li><a href="global.html#registerDependency">registerDependency</a></li><li><a href="global.html#registerHealthCheck">registerHealthCheck</a></li><li><a href="global.html#reinstallDependencies">reinstallDependencies</a></li><li><a href="global.html#reload">reload</a></li><li><a href="global.html#restartProcess">restartProcess</a></li><li><a href="global.html#retryConnection">retryConnection</a></li><li><a href="global.html#selectRecoveryStrategy">selectRecoveryStrategy</a></li><li><a href="global.html#setupHandlers">setupHandlers</a></li><li><a href="global.html#setupMonitoring">setupMonitoring</a></li><li><a href="global.html#softRestart">softRestart</a></li><li><a href="global.html#startHealthMonitoring">startHealthMonitoring</a></li><li><a href="global.html#startPerformanceProfile">startPerformanceProfile</a></li><li><a href="global.html#validateEnterpriseConfig">validateEnterpriseConfig</a></li><li><a href="global.html#withCacheMonitoring">withCacheMonitoring</a></li><li><a href="global.html#withDatabaseMonitoring">withDatabaseMonitoring</a></li><li><a href="global.html#withModelMonitoring">withModelMonitoring</a></li><li><a href="global.html#withQueueMonitoring">withQueueMonitoring</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Mon Aug 18 2025 01:43:35 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
